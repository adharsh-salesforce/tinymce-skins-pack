import * as LoggedError from './LoggedError';
import * as TestError from './TestError';
import * as TestLogs from './TestLogs';
var cleanStack = function (error, linesToRemove) {
    if (linesToRemove === void 0) { linesToRemove = 1; }
    if (error.stack === undefined) {
        return '';
    }
    var lines = error.stack.split('\n');
    var message = lines[0];
    // If the first line is the `normalizeError` function then we have no message (e.g. Firefox errors)
    if (message.indexOf('normalizeError') !== -1) {
        var stack = lines.slice(linesToRemove);
        return stack.join('\n');
    }
    else {
        var stack = lines.slice(1 + linesToRemove);
        return message + '\n' + stack.join('\n');
    }
};
export var normalizeError = function (err) {
    if (typeof err === 'string') {
        // Create an error object, but strip the stack of the 2 latest calls as it'll
        // just be this function and the previous function that called this (ie asyncTest)
        var error = new Error(err);
        error.stack = cleanStack(error, 2);
        return error;
    }
    else if (typeof err === 'function') {
        return normalizeError(err());
    }
    else if (TestError.isAssertionError(err)) {
        // Chai assertion errors are objects, but we want an actual error
        // so it prints better in the console
        var error_1 = new Error(err.message);
        error_1.name = err.name;
        error_1.stack = err.stack;
        var keys = Object.keys(err);
        keys.forEach(function (key) {
            error_1[key] = err[key];
        });
        return error_1;
    }
    else {
        return err;
    }
};
var processLog = function (logs) {
    var outputToStr = function (numIndent, entries) {
        var everything = [];
        var indentString = '';
        for (var i = 0; i < numIndent; i++) {
            indentString += ' ';
        }
        var _loop_1 = function (i) {
            var entry = entries[i];
            var output = (function () {
                var traceLines = entry.trace === null || typeof entry.trace !== 'string' ? [] : ['', ''].concat(entry.trace.split('\n'));
                if (entry.entries.length === 0) {
                    if (entry.trace === null) {
                        return [indentString + '*  ' + entry.message];
                    }
                    else {
                        return [indentString + '*  ' + entry.message].concat(traceLines);
                    }
                }
                else {
                    // We have entries ... let's format them.
                    return [indentString + '*  ' + entry.message].concat(outputToStr(numIndent + 2, entry.entries)).concat(traceLines);
                }
            })();
            everything = everything.concat(output);
        };
        for (var i = 0; i < entries.length; i++) {
            _loop_1(i);
        }
        return everything;
    };
    return outputToStr(2, logs.history);
};
export var prepFailure = function (err, logs) {
    if (logs === void 0) { logs = TestLogs.init(); }
    if (LoggedError.isLoggedError(err)) {
        return err;
    }
    else {
        var normalizedErr = normalizeError(err);
        var failureMessage = processLog(logs);
        return LoggedError.loggedError(normalizedErr, failureMessage);
    }
};
//# sourceMappingURL=Failure.js.map