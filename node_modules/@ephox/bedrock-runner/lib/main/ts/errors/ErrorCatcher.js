import { Global, Type } from '@ephox/bedrock-common';
import { setStack } from '../core/Utils';
import { isInternalError } from './Errors';
// instanceof doesn't work with cross frame errors so we need
// to rely on duck-typing to check if we have an error
var isError = function (e) {
    return Type.isObject(e) && (e instanceof Error ||
        Type.isString(e.message) && Type.isString(e.stack));
};
export var ErrorCatcher = function () {
    var supportsGlobalEventListeners = Global.addEventListener !== undefined;
    var onErrorHandlers = new Set();
    var bound = false;
    var createHandler = function (extractError) { return function (e) {
        if (onErrorHandlers.size > 0) {
            var error_1 = extractError(e);
            onErrorHandlers.forEach(function (onError) { return onError(error_1); });
            e.preventDefault();
            return false;
        }
        else {
            return true;
        }
    }; };
    var onUnhandledRejection = createHandler(function (e) {
        if (isError(e.reason)) {
            var error = new Error("Unhandled promise rejection: ".concat(e.reason.message));
            setStack(error, e.reason.stack);
            return error;
        }
        else {
            return new Error("Unhandled promise rejection: ".concat(e.reason));
        }
    });
    var onUncaughtError = createHandler(function (e) {
        if (isError(e.error)) {
            if (isInternalError(e.error)) {
                return e.error;
            }
            else {
                var error = new Error(e.message);
                setStack(error, e.error.stack);
                return error;
            }
        }
        else {
            return new Error("".concat(e.message, " (").concat(e.filename, ":").concat(e.lineno, ")"));
        }
    });
    var bind = function () {
        if (supportsGlobalEventListeners && !bound) {
            bound = true;
            Global.addEventListener('error', onUncaughtError);
            Global.addEventListener('unhandledrejection', onUnhandledRejection);
        }
    };
    var unbind = function () {
        if (bound) {
            bound = false;
            Global.removeEventListener('error', onUncaughtError);
            Global.removeEventListener('unhandledrejection', onUnhandledRejection);
        }
    };
    var addHandler = function (onError) {
        onErrorHandlers.add(onError);
        bind();
        return {
            unbind: function () { return onErrorHandlers.delete(onError); }
        };
    };
    return {
        bind: addHandler,
        destroy: unbind
    };
};
//# sourceMappingURL=ErrorCatcher.js.map