import { Failure } from '@ephox/bedrock-common';
import Promise from '@ephox/wrap-promise-polyfill';
import { isInternalError, MultipleDone, SkipError } from '../errors/Errors';
import { ErrorCatcher } from '../errors/ErrorCatcher';
import { Timer } from './Timer';
var isPromiseLike = function (value) {
    return value !== undefined && value.then !== undefined;
};
var errorCatcher = ErrorCatcher();
export var runWithErrorCatcher = function (runnable, fn) {
    return new Promise(function (resolve, reject) {
        var errorOccurred = false;
        var catcher = errorCatcher.bind(function (e) {
            if (!errorOccurred) {
                errorOccurred = true;
                var err = isInternalError(e) ? e : Failure.prepFailure(e);
                runnable.setResult("failed" /* Failed */, err);
                reject(err);
            }
        });
        fn().then(function (result) {
            catcher.unbind();
            if (!errorOccurred) {
                resolve(result);
            }
        }, function (e) {
            catcher.unbind();
            if (!errorOccurred) {
                reject(e);
            }
        });
    });
};
var runExecFn = function (fn, context) {
    return new Promise(function (resolve, reject) {
        var doneCalled = false;
        var done = function (err) {
            if (doneCalled) {
                throw new MultipleDone('done() called multiple times', err);
            }
            else if (err !== undefined) {
                reject(Failure.prepFailure(err));
            }
            else {
                resolve();
            }
            doneCalled = true;
        };
        try {
            // If the function has 1 or more arguments, it's using the async callback
            var retValue = fn.call(context, done);
            if (fn.length === 0) {
                if (isPromiseLike(retValue)) {
                    retValue.then(function () { return done(); }, done);
                }
                else {
                    resolve();
                }
            }
        }
        catch (e) {
            var err = isInternalError(e) ? e : Failure.prepFailure(e);
            reject(err);
        }
    });
};
export var run = function (runnable, context) {
    // Ensure we don't run if we already have a result or don't have anything to run
    if (runnable.isFailed()) {
        return Promise.reject(runnable.error);
    }
    else if (runnable.isSkipped()) {
        return Promise.reject(new SkipError());
    }
    else if (runnable.fn === undefined) {
        return Promise.resolve();
    }
    else {
        return runExecFn(runnable.fn, context).catch(function (e) {
            // Update the runnable state when an error occurs
            if (e instanceof SkipError) {
                runnable.setResult("skipped" /* Skipped */);
            }
            else {
                runnable.setResult("failed" /* Failed */, e);
            }
            return Promise.reject(e);
        });
    }
};
var runWithCleanup = function (runnable, context, cleanup) {
    return run(runnable, context).then(cleanup, function (e) {
        cleanup();
        return Promise.reject(e);
    });
};
export var runWithTimeout = function (runnable, context, defaultTimeout) {
    // Update the runnable timeout to use the default timeout if required
    if (runnable.timeout() === -1) {
        runnable.timeout(defaultTimeout);
    }
    // Run the execute function with a timeout if required
    if (runnable.timeout() <= 0) {
        return run(runnable, context);
    }
    else {
        return new Promise(function (resolve, reject) {
            var timer = Timer();
            var resolveIfNotTimedOut = function () {
                if (!timer.hasTimedOut()) {
                    resolve();
                }
            };
            // If the runnable sets a timeout while running then we need to restart the timer
            var unbind = runnable._onChange('timeout', timer.restart);
            // Start the timer
            timer.start(runnable.timeout(), function () {
                unbind();
                reject(Failure.prepFailure(new Error("Test ran too long - timeout of ".concat(runnable.timeout(), "ms exceeded"))));
            });
            // Run the execute function and clean up after it's completed
            runWithCleanup(runnable, context, function () {
                timer.stop();
                unbind();
            }).then(resolveIfNotTimedOut, reject);
        });
    }
};
//# sourceMappingURL=Run.js.map