import Promise from '@ephox/wrap-promise-polyfill';
import * as Context from '../core/Context';
import { SkipError } from '../errors/Errors';
import { runWithErrorCatcher, runWithTimeout } from './Run';
import { loop } from './Utils';
var DEFAULT_HOOK_TIMEOUT = 2000;
export var getHooks = function (suite, type, includeParents) {
    if (suite.isSkipped()) {
        return [];
    }
    else {
        var hooks = suite.hooks[type];
        if (includeParents && suite.parent !== undefined) {
            var parentHooks = getHooks(suite.parent, type, includeParents);
            // Reverse the suite hook order for after hooks so it gets the suite hooks bottom up
            if (type === "after" /* After */ || type === "afterEach" /* AfterEach */) {
                return hooks.concat(parentHooks);
            }
            else {
                return parentHooks.concat(hooks);
            }
        }
        else {
            return hooks;
        }
    }
};
var handleSkippedHook = function (suite, type, currentTest) {
    if (type === "before" /* Before */) {
        suite.suites.forEach(function (childSuite) {
            childSuite._skip = true;
        });
        suite.tests.forEach(function (test) {
            test.setResult("skipped" /* Skipped */);
        });
    }
    else if (type === "beforeEach" /* BeforeEach */ && currentTest !== undefined) {
        currentTest.setResult("skipped" /* Skipped */);
    }
};
export var runHooks = function (suite, type, runOnParents, currentTest) {
    var hooks = getHooks(suite, type, runOnParents);
    return loop(hooks, function (hook) {
        return runWithErrorCatcher(hook, function () { return runWithTimeout(hook, Context.createContext(hook, currentTest), DEFAULT_HOOK_TIMEOUT); });
    }).catch(function (e) {
        if (e instanceof SkipError) {
            handleSkippedHook(suite, type, currentTest);
            return Promise.resolve();
        }
        else {
            return Promise.reject(e);
        }
    });
};
export var runBefore = function (suite, currentTest) {
    return runHooks(suite, "before" /* Before */, false, currentTest);
};
export var runAfter = function (suite, currentTest) {
    return runHooks(suite, "after" /* After */, false, currentTest);
};
export var runBeforeEach = function (currentTest) {
    if (currentTest.parent !== undefined) {
        return runHooks(currentTest.parent, "beforeEach" /* BeforeEach */, true, currentTest);
    }
    else {
        return Promise.resolve();
    }
};
export var runAfterEach = function (currentTest) {
    if (currentTest.parent !== undefined) {
        return runHooks(currentTest.parent, "afterEach" /* AfterEach */, true, currentTest);
    }
    else {
        return Promise.resolve();
    }
};
//# sourceMappingURL=Hooks.js.map