import Promise from '@ephox/wrap-promise-polyfill';
import { noop } from '../core/Utils';
import { Actions } from '../ui/Actions';
import { runSuite } from './TestRun';
import { countTests, filterOnly } from './Utils';
// 5sec interval for the server to know the client hasn't disconnected
// Note: The interval needs to be less than 10secs, otherwise the server will disconnect.
//       See `Controller.ts` in the server.
var KEEP_ALIVE_INTERVAL = 5000;
export var Runner = function (rootSuite, params, callbacks, reporter, ui) {
    var actions = Actions(params.session);
    var numTests = 0;
    var withSum = function (action, offset, failedOffset, skippedOffset) {
        if (offset === void 0) { offset = 0; }
        if (failedOffset === void 0) { failedOffset = 0; }
        if (skippedOffset === void 0) { skippedOffset = 0; }
        return function (retry) {
            var sum = reporter.summary();
            action(sum.offset + offset, sum.failed + failedOffset, sum.skipped + skippedOffset, retry);
        };
    };
    var runNextChunk = function (offset) {
        var sum = reporter.summary();
        actions.reloadPage(offset, sum.failed, sum.skipped);
    };
    var retryTest = withSum(actions.retryTest);
    var loadNextTest = withSum(actions.nextTest);
    var stopTest = withSum(actions.updateHistory, 0, -1);
    var onTestPass = function () {
        var sum = reporter.summary();
        if (params.retry > 0) {
            params.retry = 0;
            actions.updateHistory(params.offset, sum.failed, sum.skipped, params.retry);
        }
    };
    var onTestFailure = function (retries, stopOnFailure) {
        if (stopOnFailure) {
            reporter.done();
            // make it easy to restart at this test
            stopTest();
        }
        else if (params.retry < retries) {
            retryTest(params.retry + 1);
        }
        else {
            loadNextTest();
        }
    };
    var init = function () {
        // Filter the tests to ensure we have an accurate total test count
        filterOnly(rootSuite);
        numTests = countTests(rootSuite);
        // Render the initial UI
        ui.render(params.offset, numTests, actions.restartTests, retryTest, loadNextTest);
        // delay this ajax call until after the reporter status elements are in the page
        var keepAliveTimer = setInterval(function () {
            callbacks.sendKeepAlive(params.session).catch(function () {
                // if the server shuts down stop trying to send messages
                clearInterval(keepAliveTimer);
            });
        }, KEEP_ALIVE_INTERVAL);
        return callbacks.sendInit(params.session).then(function () { return callbacks.loadHarness(); });
    };
    var run = function (chunk, retries, timeout, stopOnFailure) {
        var runState = {
            totalTests: numTests,
            offset: params.offset,
            chunk: chunk,
            timeout: timeout,
            testCount: 0
        };
        var runActions = {
            onFailure: function () { return onTestFailure(retries, stopOnFailure); },
            onPass: onTestPass,
            onSkip: onTestPass,
            onStart: noop,
            runNextChunk: runNextChunk
        };
        ui.setStopOnFailure(stopOnFailure);
        return runSuite(rootSuite, runState, runActions, reporter)
            .then(function () {
            reporter.done();
            // for easy rerun reset the URL
            actions.updateHistory(0, 0, 0);
        }, function (e) {
            // An error handled by the test runner won't return an error object and will just reject.
            // So if we have an error, it means an unexpected/unhandled error occurred in the promise
            // chain. If we have no error then the runner has finished due to a test failure.
            if (e !== undefined) {
                return Promise.reject(e);
            }
            else {
                return Promise.resolve();
            }
        });
    };
    return {
        init: init,
        run: run
    };
};
//# sourceMappingURL=Runner.js.map