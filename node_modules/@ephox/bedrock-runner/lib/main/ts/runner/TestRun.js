import { Failure } from '@ephox/bedrock-common';
import Promise from '@ephox/wrap-promise-polyfill';
import * as Context from '../core/Context';
import { isInternalError, SkipError } from '../errors/Errors';
import * as Hooks from './Hooks';
import { runWithErrorCatcher, runWithTimeout } from './Run';
import { countTests, loop } from './Utils';
var runTestWithRetry = function (test, state, report, retryCount) {
    if (test.isSkipped()) {
        return Promise.reject(new SkipError());
    }
    else {
        var runAfterHooks = function (error) { return function (result) {
            return Hooks.runAfterEach(test).then(function () { return error ? Promise.reject(result) : Promise.resolve(result); });
        }; };
        return Hooks.runBeforeEach(test)
            .then(function () { return runWithErrorCatcher(test, function () { return runWithTimeout(test, Context.createContext(test, test), state.timeout); }); })
            // Ensure we run the afterEach hooks no matter if the test failed
            .then(runAfterHooks(false), runAfterHooks(true))
            .catch(function (e) {
            if (retryCount < test.retries() && !isInternalError(e)) {
                test.setResult("notrun" /* NotRun */);
                return report.retry().then(function () { return runTestWithRetry(test, state, report, retryCount + 1); });
            }
            else {
                return Promise.reject(e);
            }
        });
    }
};
export var runTest = function (test, state, actions, reporter) {
    var fail = function (report, e) {
        test.setResult("failed" /* Failed */, e);
        console.error(e);
        return report.fail(e).then(actions.onFailure).then(function () { return Promise.reject(); });
    };
    var skip = function (report) {
        test.setResult("skipped" /* Skipped */);
        return report.skip(test.title).then(actions.onSkip);
    };
    var pass = function (report) {
        test.setResult("passed" /* Passed */);
        return report.pass().then(actions.onPass);
    };
    state.testCount++;
    if (state.testCount <= state.offset) {
        return Promise.resolve();
    }
    else if (state.testCount > state.offset + state.chunk) {
        actions.runNextChunk(state.offset + state.chunk);
        // Reject so no other tests are run
        return Promise.reject();
    }
    else {
        var report_1 = reporter.test(test.file || 'Unknown', test.fullTitle(), state.totalTests);
        actions.onStart(test);
        return report_1.start()
            .then(function () { return runTestWithRetry(test, state, report_1, 0); })
            .then(function () { return pass(report_1); }, function (e) {
            if (e instanceof SkipError) {
                return skip(report_1);
            }
            else {
                return fail(report_1, Failure.prepFailure(e));
            }
        });
    }
};
export var runTests = function (tests, state, actions, reporter) {
    return loop(tests, function (test) { return runTest(test, state, actions, reporter); });
};
export var runSuite = function (suite, state, actions, reporter) {
    var numTests = countTests(suite);
    if (state.testCount + numTests <= state.offset) {
        state.testCount += numTests;
        return Promise.resolve();
    }
    else {
        var runAfterHooks = function (error) { return function (result) {
            return Hooks.runAfter(suite).then(function () { return error ? Promise.reject(result) : Promise.resolve(result); });
        }; };
        return Hooks.runBefore(suite)
            .then(function () { return runTests(suite.tests, state, actions, reporter); })
            .then(function () { return runSuites(suite.suites, state, actions, reporter); })
            // Ensure we run the after hooks no matter if the tests/suites fail
            .then(runAfterHooks(false), runAfterHooks(true));
    }
};
export var runSuites = function (suites, state, actions, reporter) {
    return loop(suites, function (suite) { return runSuite(suite, state, actions, reporter); });
};
//# sourceMappingURL=TestRun.js.map