import { Reporter as ErrorReporter } from '@ephox/bedrock-common';
import Promise from '@ephox/wrap-promise-polyfill';
import { formatElapsedTime, mapStackTrace, setStack } from '../core/Utils';
var elapsed = function (since) { return formatElapsedTime(since, new Date()); };
var mapError = function (e) { return mapStackTrace(e.stack).then(function (mappedStack) {
    var originalStack = e.stack;
    setStack(e, mappedStack);
    // Logs may have the stack trace included as well, so ensure we replace that as well
    if (e.logs !== undefined && e.logs.length > 0 && originalStack !== undefined) {
        var logs = e.logs.join('\n');
        e.logs = logs.replace(originalStack, mappedStack).split('\n');
    }
    return Promise.resolve(e);
}); };
export var Reporter = function (params, callbacks, ui) {
    var initial = new Date();
    var currentCount = params.offset || 0;
    var passCount = 0;
    var skipCount = 0;
    var failCount = 0;
    var summary = function () { return ({
        offset: Math.max(0, currentCount - 1),
        passed: passCount + (params.offset - params.failed - params.skipped),
        failed: failCount + params.failed,
        skipped: skipCount + params.skipped
    }); };
    var test = function (file, name, totalNumTests) {
        var starttime;
        var reported = false;
        var started = false;
        var testUi = ui.test();
        var start = function () {
            if (started) {
                return Promise.resolve();
            }
            else {
                started = true;
                starttime = new Date();
                currentCount++;
                testUi.start(file, name);
                return callbacks.sendTestStart(params.session, totalNumTests, file, name);
            }
        };
        var retry = function () {
            starttime = new Date();
            return Promise.resolve();
        };
        var pass = function () {
            if (reported) {
                return Promise.resolve();
            }
            else {
                reported = true;
                passCount++;
                var testTime = elapsed(starttime);
                testUi.pass(testTime, currentCount);
                return callbacks.sendTestResult(params.session, file, name, true, testTime, null, null);
            }
        };
        var skip = function (reason) {
            if (reported) {
                return Promise.resolve();
            }
            else {
                reported = true;
                skipCount++;
                var testTime = elapsed(starttime);
                testUi.skip(testTime, currentCount);
                return callbacks.sendTestResult(params.session, file, name, false, testTime, null, reason);
            }
        };
        var fail = function (e) {
            if (reported) {
                return Promise.resolve();
            }
            else {
                reported = true;
                failCount++;
                var testTime_1 = elapsed(starttime);
                return mapError(e).then(function (err) {
                    var errorData = ErrorReporter.data(err);
                    var error = {
                        data: errorData,
                        text: ErrorReporter.dataText(errorData)
                    };
                    testUi.fail(err, testTime_1, currentCount);
                    return callbacks.sendTestResult(params.session, file, name, false, testTime_1, error, null);
                });
            }
        };
        return {
            start: start,
            retry: retry,
            pass: pass,
            skip: skip,
            fail: fail
        };
    };
    var done = function (error) {
        var setAsDone = function () {
            var totalTime = elapsed(initial);
            ui.done(totalTime);
        };
        var textError = error !== undefined ? ErrorReporter.text(error) : undefined;
        callbacks.sendDone(params.session, textError).then(setAsDone, setAsDone);
    };
    return {
        summary: summary,
        test: test,
        done: done
    };
};
//# sourceMappingURL=Reporter.js.map