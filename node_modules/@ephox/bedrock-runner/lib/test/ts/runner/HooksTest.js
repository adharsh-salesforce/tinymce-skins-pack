import { assert } from 'chai';
import { beforeEach, describe, it } from 'mocha';
import { createHook } from '../../../main/ts/core/Hook';
import { createSuite, createRootSuite } from '../../../main/ts/core/Suite';
import { createTest } from '../../../main/ts/core/Test';
import * as Hooks from '../../../main/ts/runner/Hooks';
import { noop } from '../TestUtils';
import * as RunnerTestUtils from './RunnerTestUtils';
describe('Hooks.getHooks', function () {
    var root;
    var nested;
    beforeEach(function () {
        root = createRootSuite('root');
        nested = createSuite('nested', root);
        RunnerTestUtils.populateHooks(root, 1);
        RunnerTestUtils.populateHooks(nested, 1);
    });
    it('include parent hooks', function () {
        var nestedHooks = Hooks.getHooks(nested, "after" /* After */, true);
        assert.lengthOf(nestedHooks, 2);
        var rootHooks = Hooks.getHooks(root, "after" /* After */, true);
        assert.lengthOf(rootHooks, 1);
    });
    it('exclude parent hooks', function () {
        var hooks = Hooks.getHooks(nested, "before" /* Before */, false);
        assert.lengthOf(hooks, 1);
    });
    it('returns no hooks when a suite is skipped', function () {
        var skippedSuite = createSuite('no-hooks', root);
        skippedSuite._skip = true;
        var beforeEachHooks = Hooks.getHooks(skippedSuite, "beforeEach" /* BeforeEach */, true);
        var afterHooks = Hooks.getHooks(skippedSuite, "after" /* After */, false);
        assert.lengthOf(beforeEachHooks, 0);
        assert.lengthOf(afterHooks, 0);
    });
});
describe('Hooks.runHooks', function () {
    var root;
    var nested;
    var callStack;
    beforeEach(function () {
        root = createRootSuite('root');
        nested = createSuite('nested', root);
        callStack = [];
        RunnerTestUtils.populateHooks(root, 2, function (idx) { return callStack.push('root' + idx); });
        RunnerTestUtils.populateHooks(nested, 2, function (idx) { return callStack.push('nested' + idx); });
    });
    it('runs beforeEach hooks from top down', function () {
        return Hooks.runHooks(nested, "beforeEach" /* BeforeEach */, true).then(function () {
            assert.deepEqual(callStack, ['root0', 'root1', 'nested0', 'nested1']);
        });
    });
    it('runs afterEach hooks from bottom up', function () {
        return Hooks.runHooks(nested, "afterEach" /* AfterEach */, true).then(function () {
            assert.deepEqual(callStack, ['nested0', 'nested1', 'root0', 'root1']);
        });
    });
    it('should skip all tests if skip() called in a before hook', function () {
        nested.hooks.before.push(createHook("before" /* Before */, function () {
            this.skip();
        }));
        var test = createTest('test', noop, nested);
        nested.tests.push(test);
        return Hooks.runBefore(nested, test).then(function () {
            assert.isTrue(test.isSkipped());
        });
    });
    it('should skip the current test if skip() called in a beforeEach hook', function () {
        nested.hooks.beforeEach.push(createHook("beforeEach" /* BeforeEach */, function () {
            this.skip();
        }));
        var test = createTest('test', noop, nested);
        nested.tests.push(test);
        return Hooks.runBeforeEach(test).then(function () {
            assert.isTrue(test.isSkipped());
        });
    });
    it('should not run additional hooks if skipped', function () {
        root.hooks.before.unshift(createHook("before" /* Before */, function () {
            this.skip();
        }));
        var test = createTest('test', noop, root);
        root.tests.push(test);
        return Hooks.runBefore(root, test).then(function () {
            assert.isTrue(test.isSkipped());
            assert.deepEqual(callStack, []);
        });
    });
    it('should handle a timeout being adjusted during execution', function () {
        root.hooks.before.push(createHook("before" /* Before */, function (done) {
            // Default timeout is 2000
            this.timeout(2500);
            setTimeout(done, 2250);
        }));
        var test = createTest('test', noop, root);
        root.tests.push(test);
        return Hooks.runBefore(root, test).then(function () {
            assert.isFalse(test.isFailed());
            assert.isFalse(test.isSkipped());
            assert.deepEqual(callStack, ['root0', 'root1']);
        });
    }).timeout(4000);
});
//# sourceMappingURL=HooksTest.js.map