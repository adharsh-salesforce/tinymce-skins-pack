import Promise from '@ephox/wrap-promise-polyfill';
import { createHook } from '../../../main/ts/core/Hook';
import { noop } from '../TestUtils';
export var TEST_TIMEOUT = 200;
export var populateHooks = function (suite, count, func) {
    if (func === void 0) { func = noop; }
    var _loop_1 = function (i) {
        var f = function (type) {
            return createHook(type, function () {
                func(i, type);
            });
        };
        suite.hooks["before" /* Before */].push(f("before" /* Before */));
        suite.hooks["beforeEach" /* BeforeEach */].push(f("beforeEach" /* BeforeEach */));
        suite.hooks["after" /* After */].push(f("after" /* After */));
        suite.hooks["afterEach" /* AfterEach */].push(f("afterEach" /* AfterEach */));
    };
    for (var i = 0; i < count; i++) {
        _loop_1(i);
    }
};
export var MockReporter = function () {
    var passed = 0;
    var skipped = 0;
    var failures = [];
    var test = function () { return ({
        start: function () { return Promise.resolve(); },
        retry: function () { return Promise.resolve(); },
        pass: function () {
            passed++;
            return Promise.resolve();
        },
        fail: function (e) {
            failures.push(e);
            return Promise.resolve();
        },
        skip: function () {
            skipped++;
            return Promise.resolve();
        }
    }); };
    return {
        test: test,
        summary: function () { return ({ offset: 0, passed: passed, failed: failures.length, skipped: skipped }); },
        done: noop,
        failures: function () { return failures; }
    };
};
export var createRunState = function (offset, chunk, count) {
    if (count === void 0) { count = 0; }
    return ({
        totalTests: 1,
        offset: offset,
        chunk: chunk,
        timeout: TEST_TIMEOUT,
        testCount: count
    });
};
//# sourceMappingURL=RunnerTestUtils.js.map