import Promise from '@ephox/wrap-promise-polyfill';
import { assert } from 'chai';
import * as fc from 'fast-check';
import { beforeEach, describe, it } from 'mocha';
import { createRootSuite } from '../../../main/ts/core/Suite';
import { createTest } from '../../../main/ts/core/Test';
import * as TestRun from '../../../main/ts/runner/TestRun';
import { noop } from '../TestUtils';
import * as RunnerTestUtils from './RunnerTestUtils';
var sleep = function (time) {
    return new Promise(function (resolve) { return setTimeout(resolve, time); });
};
var createMockTest = function (name, suite, testFn) {
    var test = createTest(name, function () {
        test.hasRun = true;
        if (testFn === undefined) {
            return Promise.resolve();
        }
        else {
            return testFn.call(this);
        }
    }, suite);
    test.hasRun = false;
    return test;
};
describe('TestRun.runTest', function () {
    var reporter;
    var suite;
    var actions;
    var loadedNextChunk;
    var onPassRun;
    var onFailureRun;
    var onSkipRun;
    var onStartRun;
    beforeEach(function () {
        loadedNextChunk = onPassRun = onFailureRun = onSkipRun = onStartRun = false;
        reporter = RunnerTestUtils.MockReporter();
        suite = createRootSuite('root');
        actions = {
            onStart: function () { return onStartRun = true; },
            onFailure: function () { return onFailureRun = true; },
            onPass: function () { return onPassRun = true; },
            onSkip: function () { return onSkipRun = true; },
            runNextChunk: function () { return loadedNextChunk = true; }
        };
    });
    it('should not run when offset is higher than the current test count', function () {
        return fc.assert(fc.asyncProperty(fc.integer(0, 100), fc.integer(1, 100), function (count, startOffset) {
            var test = createMockTest('test', suite);
            var state = RunnerTestUtils.createRunState(count + startOffset, 10, count);
            return TestRun.runTest(test, state, actions, reporter).then(function () {
                assert.isNotTrue(test.hasRun);
                assert.isNotTrue(onStartRun);
                assert.isNotTrue(onPassRun);
                assert.isNotTrue(onSkipRun);
                assert.isNotTrue(onFailureRun);
                assert.isNotTrue(loadedNextChunk);
            });
        }));
    });
    it('should load next chunk when count is higher than the start offset + chunk', function () {
        return fc.assert(fc.asyncProperty(fc.integer(0, 100), fc.integer(1, 100), function (startOffset, chunk) {
            var test = createMockTest('test', suite);
            var state = RunnerTestUtils.createRunState(startOffset, chunk, startOffset + chunk);
            return TestRun.runTest(test, state, actions, reporter).catch(function () {
                assert.isNotTrue(test.hasRun);
                assert.isNotTrue(onStartRun);
                assert.isNotTrue(onPassRun);
                assert.isNotTrue(onSkipRun);
                assert.isNotTrue(onFailureRun);
                assert.isTrue(loadedNextChunk);
            });
        }));
    });
    it('should run when count is higher than offset', function () {
        return fc.assert(fc.asyncProperty(fc.integer(0, 100), fc.integer(0, 100), function (count, offset) {
            var test = createMockTest('test', suite);
            var state = RunnerTestUtils.createRunState(offset, 200, offset + count);
            return TestRun.runTest(test, state, actions, reporter).then(function () {
                assert.isTrue(test.hasRun);
                assert.isTrue(onStartRun);
                assert.isTrue(onPassRun);
                assert.isNotTrue(onSkipRun);
                assert.isNotTrue(onFailureRun);
                assert.isNotTrue(loadedNextChunk);
            });
        }));
    });
    it('should not run when test is skipped', function () {
        return fc.assert(fc.asyncProperty(fc.integer(0, 100), fc.integer(0, 100), function (count, offset) {
            var test = createMockTest('test', suite);
            test.setResult("skipped" /* Skipped */);
            var state = RunnerTestUtils.createRunState(offset, 200, offset + count);
            return TestRun.runTest(test, state, actions, reporter).then(function () {
                assert.isNotTrue(test.hasRun);
                assert.isTrue(onStartRun);
                assert.isNotTrue(onPassRun);
                assert.isTrue(onSkipRun);
                assert.isNotTrue(onFailureRun);
                assert.isNotTrue(loadedNextChunk);
            });
        }));
    });
    it('should run multiple times when retries is enabled', function () {
        var count = 0;
        var test = createMockTest('test', suite, function () {
            if (count++ < 3) {
                return Promise.reject(new Error('Test has not repeated enough times'));
            }
            else {
                return Promise.resolve();
            }
        });
        test.retries(3);
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runTest(test, state, actions, reporter).then(function () {
            assert.isTrue(test.hasRun);
            assert.isTrue(onStartRun);
            assert.isTrue(onPassRun);
            assert.isNotTrue(onSkipRun);
            assert.isNotTrue(onFailureRun);
            assert.isNotTrue(loadedNextChunk);
        });
    });
    it('should fail on default test timeout', function () {
        var test = createMockTest('test', suite, function () {
            return sleep(RunnerTestUtils.TEST_TIMEOUT + 100);
        });
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        TestRun.runTest(test, state, actions, reporter);
        // Wait for the test to have timed out and then run assertions
        return sleep(RunnerTestUtils.TEST_TIMEOUT + 200).then(function () {
            assert.deepEqual(reporter.summary(), { offset: 0, failed: 1, passed: 0, skipped: 0 });
            assert.isTrue(test.hasRun);
            assert.isTrue(onStartRun);
            assert.isNotTrue(onPassRun);
            assert.isNotTrue(onSkipRun);
            assert.isTrue(onFailureRun);
            assert.isNotTrue(loadedNextChunk);
            assert.equal(reporter.failures()[0].message, "Test ran too long - timeout of ".concat(RunnerTestUtils.TEST_TIMEOUT, "ms exceeded"));
        });
    });
    it('should fail on explicit test timeout', function () {
        var test = createMockTest('test', suite, function () {
            return sleep(100);
        });
        test.timeout(50);
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        TestRun.runTest(test, state, actions, reporter);
        // Wait for the test to have timed out and then run assertions
        return sleep(200).then(function () {
            assert.deepEqual(reporter.summary(), { offset: 0, failed: 1, passed: 0, skipped: 0 });
            assert.isTrue(test.hasRun);
            assert.isTrue(onStartRun);
            assert.isNotTrue(onPassRun);
            assert.isNotTrue(onSkipRun);
            assert.isTrue(onFailureRun);
            assert.isNotTrue(loadedNextChunk);
            assert.equal(reporter.failures()[0].message, "Test ran too long - timeout of 50ms exceeded");
        });
    });
    it('should not timeout if the timeout is disabled', function () {
        var test = createMockTest('test', suite, function () {
            return sleep(RunnerTestUtils.TEST_TIMEOUT + 100);
        });
        test.timeout(0); // Disable the timeout
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        TestRun.runTest(test, state, actions, reporter);
        // Wait for the test to have timed out and then run assertions
        return sleep(RunnerTestUtils.TEST_TIMEOUT + 200)
            .then(function () {
            assert.deepEqual(reporter.summary(), { offset: 0, failed: 0, passed: 1, skipped: 0 });
            assert.isTrue(test.hasRun);
            assert.isTrue(onStartRun);
            assert.isTrue(onPassRun);
            assert.isNotTrue(onSkipRun);
            assert.isNotTrue(onFailureRun);
            assert.isNotTrue(loadedNextChunk);
        });
    });
    it('should run beforeEach and afterEach hooks', function () {
        var hooks = [];
        RunnerTestUtils.populateHooks(suite, 1, function (_idx, type) {
            hooks.push(type);
        });
        var test = createMockTest('test', suite);
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runTest(test, state, actions, reporter).then(function () {
            assert.isTrue(test.hasRun);
            assert.deepEqual(hooks, ["beforeEach" /* BeforeEach */, "afterEach" /* AfterEach */]);
        });
    });
    it('should not run beforeEach and afterEach hooks on a skipped test', function () {
        var hooks = [];
        RunnerTestUtils.populateHooks(suite, 1, function (_idx, type) {
            hooks.push(type);
        });
        var test = createMockTest('test', suite);
        test.setResult("skipped" /* Skipped */);
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runTest(test, state, actions, reporter).then(function () {
            assert.isNotTrue(test.hasRun);
            assert.deepEqual(hooks, []);
        });
    });
    it('should run beforeEach and afterEach hooks on a lazily skipped test', function () {
        var hooks = [];
        RunnerTestUtils.populateHooks(suite, 1, function (_idx, type) {
            hooks.push(type);
        });
        var test = createMockTest('test', suite, function () {
            this.skip();
            return Promise.resolve();
        });
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runTest(test, state, actions, reporter).then(function () {
            assert.isTrue(test.hasRun);
            assert.deepEqual(hooks, ["beforeEach" /* BeforeEach */, "afterEach" /* AfterEach */]);
        });
    });
    it('should run beforeEach and afterEach hooks on a test failure', function () {
        var hooks = [];
        RunnerTestUtils.populateHooks(suite, 1, function (_idx, type) {
            hooks.push(type);
        });
        var test = createMockTest('test', suite, function () { return Promise.reject('die'); });
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runTest(test, state, actions, reporter).catch(function () {
            assert.isTrue(test.hasRun);
            assert.deepEqual(hooks, ["beforeEach" /* BeforeEach */, "afterEach" /* AfterEach */]);
        });
    });
    it('should have the failed test state setup in an afterEach hook', function () {
        var states = [];
        RunnerTestUtils.populateHooks(suite, 1, function () {
            if (test.isFailed()) {
                states.push("failed" /* Failed */);
            }
            else if (test.isSkipped()) {
                states.push("skipped" /* Skipped */);
            }
            else {
                states.push("notrun" /* NotRun */);
            }
        });
        var test = createMockTest('test', suite, function () { return Promise.reject('die'); });
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runTest(test, state, actions, reporter).catch(function () {
            assert.isTrue(test.hasRun);
            assert.deepEqual(states, ["notrun" /* NotRun */, "failed" /* Failed */]);
        });
    });
});
describe('TestRun.runSuite', function () {
    var reporter;
    var suite;
    var test;
    var actions;
    beforeEach(function () {
        reporter = RunnerTestUtils.MockReporter();
        suite = createRootSuite('root');
        test = createMockTest('test', suite);
        suite.tests.push(test);
        actions = {
            onStart: noop,
            onFailure: noop,
            onPass: noop,
            onSkip: noop,
            runNextChunk: noop
        };
    });
    it('should not run when offset is higher than the current + suite test count', function () {
        var hasRunSuite = false;
        RunnerTestUtils.populateHooks(suite, 1, function () { return hasRunSuite = true; });
        return fc.assert(fc.asyncProperty(fc.integer(0, 100), fc.integer(1, 100), function (count, startOffset) {
            var state = RunnerTestUtils.createRunState(count + startOffset, 200, 0);
            return TestRun.runSuite(suite, state, actions, reporter).then(function () {
                assert.isNotTrue(test.hasRun);
                assert.isNotTrue(hasRunSuite);
            });
        }));
    });
    it('should run before and after hooks', function () {
        var hooks = [];
        RunnerTestUtils.populateHooks(suite, 1, function (_idx, type) {
            hooks.push(type);
        });
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runSuite(suite, state, actions, reporter).then(function () {
            assert.isTrue(test.hasRun);
            assert.deepEqual(hooks, ["before" /* Before */, "beforeEach" /* BeforeEach */, "afterEach" /* AfterEach */, "after" /* After */]);
        });
    });
    it('should note run before and after hooks on a skipped suite', function () {
        var hooks = [];
        RunnerTestUtils.populateHooks(suite, 1, function (_idx, type) {
            hooks.push(type);
        });
        suite._skip = true;
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runSuite(suite, state, actions, reporter).then(function () {
            assert.isNotTrue(test.hasRun);
            assert.deepEqual(hooks, []);
        });
    });
    it('should run before and after hooks on a test failure', function () {
        var hooks = [];
        RunnerTestUtils.populateHooks(suite, 1, function (_idx, type) {
            hooks.push(type);
        });
        var failingTest = createMockTest('fail test', suite, function () { return Promise.reject('die'); });
        suite.tests.push(failingTest);
        var state = RunnerTestUtils.createRunState(0, 100, 0);
        return TestRun.runSuite(suite, state, actions, reporter).catch(function () {
            assert.isTrue(test.hasRun);
            assert.isTrue(failingTest.hasRun);
            assert.deepEqual(hooks, ["before" /* Before */, "beforeEach" /* BeforeEach */, "afterEach" /* AfterEach */, "beforeEach" /* BeforeEach */, "afterEach" /* AfterEach */, "after" /* After */]);
        });
    });
});
//# sourceMappingURL=TestRunTest.js.map