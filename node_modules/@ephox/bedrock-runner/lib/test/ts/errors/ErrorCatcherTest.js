import { Global } from '@ephox/bedrock-common';
import { assert } from 'chai';
import { after, afterEach, before, beforeEach, describe, it } from 'mocha';
import { ErrorCatcher } from '../../../main/ts/errors/ErrorCatcher';
describe('ErrorCatcher', function () {
    var originalAddEventListener = Global.addEventListener;
    var originalRemoveEventListener = Global.removeEventListener;
    var eventHandlers = {
        error: [],
        unhandledrejection: []
    };
    var errorCatcher;
    var errors = [];
    var unbind;
    before(function () {
        Global.addEventListener = function (name, fn) {
            eventHandlers[name].push(fn);
        };
        Global.removeEventListener = function (name, fn) {
            eventHandlers[name] = eventHandlers[name].filter(function (func) { return func !== fn; });
        };
        errorCatcher = ErrorCatcher();
    });
    after(function () {
        Global.addEventListener = originalAddEventListener;
        Global.removeEventListener = originalRemoveEventListener;
    });
    beforeEach(function () {
        unbind = errorCatcher.bind(function (e) { return errors.push(e); }).unbind;
    });
    afterEach(function () {
        unbind();
        errors = [];
    });
    var fireEvent = function (name, event) {
        eventHandlers[name].forEach(function (fn) { return fn(event); });
    };
    it('should notify on unhandled exceptions (with error)', function () {
        var prevented = false;
        var err = new Error('message');
        var unhandledException = {
            message: 'Unhandled error: message',
            error: err,
            preventDefault: function () {
                prevented = true;
            }
        };
        fireEvent('error', unhandledException);
        assert.lengthOf(errors, 1, 'Should contain one caught error');
        var error = errors[0];
        assert.equal(error.message, 'Unhandled error: message');
        assert.equal(error.stack, err.stack);
        assert.isTrue(prevented, 'Event should be prevented from running the default action');
    });
    it('should notify on unhandled exceptions (without error)', function () {
        var prevented = false;
        var unhandledException = {
            message: 'Unhandled error: message',
            lineno: 10,
            filename: 'ErrorFile.ts',
            preventDefault: function () {
                prevented = true;
            }
        };
        fireEvent('error', unhandledException);
        assert.lengthOf(errors, 1, 'Should contain one caught error');
        var error = errors[0];
        assert.equal(error.message, 'Unhandled error: message (ErrorFile.ts:10)');
        assert.isTrue(prevented, 'Event should be prevented from running the default action');
    });
    it('should notify on unhandled promise rejection', function () {
        var prevented = false;
        var err = new Error('message');
        var unhandledPromiseRejection = {
            reason: err,
            preventDefault: function () {
                prevented = true;
            }
        };
        fireEvent('unhandledrejection', unhandledPromiseRejection);
        assert.lengthOf(errors, 1, 'Should contain one caught error');
        var error = errors[0];
        assert.equal(error.message, 'Unhandled promise rejection: message');
        assert.equal(error.stack, err.stack);
        assert.isTrue(prevented, 'Event should be prevented from running the default action');
    });
    it('should not notify when there are no event listeners bound', function () {
        var prevented = false;
        var event = {
            preventDefault: function () {
                prevented = true;
            }
        };
        unbind();
        fireEvent('error', event);
        fireEvent('unhandledrejection', event);
        assert.lengthOf(errors, 0);
        assert.isFalse(prevented, 'Event should not be prevented from running the default action');
    });
    it('should handle cross frame errors', function () {
        var prevented = false;
        // Note: As this doesn't run in the browser we can't do a proper cross frame check so simulate an Error
        // that doesn't use the current Error prototype
        var frameError = {
            message: 'frame message',
            name: 'Error',
            stack: 'Error\n    at <anonymous>:1:1'
        };
        var unhandledException = {
            message: 'Unhandled error: frame message',
            error: frameError,
            preventDefault: function () {
                prevented = true;
            }
        };
        fireEvent('error', unhandledException);
        assert.lengthOf(errors, 1, 'Should contain one caught error');
        var error = errors[0];
        assert.equal(error.message, 'Unhandled error: frame message');
        assert.equal(error.stack, frameError.stack);
        assert.isTrue(prevented, 'Event should be prevented from running the default action');
    });
});
//# sourceMappingURL=ErrorCatcherTest.js.map