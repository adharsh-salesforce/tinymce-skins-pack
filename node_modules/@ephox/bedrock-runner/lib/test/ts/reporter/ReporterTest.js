var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { Failure, LoggedError } from '@ephox/bedrock-common';
import Promise from '@ephox/wrap-promise-polyfill';
import { assert } from 'chai';
import * as fc from 'fast-check';
import { beforeEach, describe, it } from 'mocha';
import { Reporter } from '../../../main/ts/reporter/Reporter';
import { noop } from '../TestUtils';
var sessionId = '111111';
var params = {
    session: sessionId,
    offset: 0,
    failed: 0,
    skipped: 0,
    retry: 0
};
var ui = {
    test: function () { return ({
        start: noop,
        pass: noop,
        skip: noop,
        fail: noop,
    }); },
    done: noop
};
describe('Reporter.test', function () {
    var reporter, startTestData, endTestData;
    var doneCalled, doneError, offset;
    var callbacks = {
        loadHarness: function () { return Promise.resolve({ retries: 0, chunk: 100, stopOnFailure: true, mode: 'manual', timeout: 10000 }); },
        sendKeepAlive: function () { return Promise.resolve(); },
        sendInit: function () { return Promise.resolve(); },
        sendTestStart: function (session, totalTests, file, name) {
            startTestData.push({ session: session, totalTests: totalTests, file: file, name: name });
            return Promise.resolve();
        },
        sendTestResult: function (session, file, name, passed, time, error, skipped) {
            endTestData.push({ session: session, file: file, name: name, passed: passed, time: time, error: error, skipped: skipped });
            return Promise.resolve();
        },
        sendDone: function (session, error) {
            doneCalled = true;
            doneError = error;
            return Promise.resolve();
        }
    };
    var reset = function () {
        offset = Math.floor(Math.random() * 1000);
        reporter = Reporter(__assign(__assign({}, params), { offset: offset }), callbacks, ui);
        startTestData = [];
        endTestData = [];
        doneCalled = false;
        doneError = undefined;
    };
    beforeEach(reset);
    it('should report the session id, number tests, file and name on start', function () {
        return fc.assert(fc.asyncProperty(fc.hexaString(), fc.asciiString(), fc.integer(offset), function (fileName, testName, testCount) {
            reset();
            var test = reporter.test(fileName + 'Test.ts', testName, testCount);
            return test.start().then(function () {
                assert.equal(startTestData.length, 1);
                assert.deepEqual(startTestData[0], {
                    session: sessionId,
                    totalTests: testCount,
                    file: fileName + 'Test.ts',
                    name: testName
                });
                assert.equal(endTestData.length, 0);
                assert.deepEqual(reporter.summary(), {
                    offset: offset,
                    passed: offset,
                    failed: 0,
                    skipped: 0
                }, 'Summary has no passed or failed tests');
                assert.isFalse(doneCalled);
            });
        }));
    });
    it('should report the session id, file, name, passed state and time on a test success', function () {
        return fc.assert(fc.asyncProperty(fc.hexaString(), fc.asciiString(), fc.integer(offset), function (fileName, testName, testCount) {
            reset();
            var test = reporter.test(fileName + 'Test.ts', testName, testCount);
            return test.start()
                .then(test.pass)
                .then(function () {
                assert.equal(endTestData.length, 1);
                var data = endTestData[0];
                assert.equal(data.session, sessionId);
                assert.equal(data.file, fileName + 'Test.ts');
                assert.equal(data.name, testName);
                assert.isTrue(data.passed);
                assert.isNull(data.skipped);
                assert.isNull(data.error);
                assert.isString(data.time);
                assert.deepEqual(reporter.summary(), {
                    offset: offset,
                    passed: offset + 1,
                    failed: 0,
                    skipped: 0
                }, 'Summary has one passed test');
                assert.isFalse(doneCalled);
            });
        }));
    });
    it('should report the session id, file, name, passed state and time on a skipped test', function () {
        return fc.assert(fc.asyncProperty(fc.hexaString(), fc.asciiString(), fc.asciiString(), fc.integer(offset), function (fileName, testName, skippedMessage, testCount) {
            reset();
            var test = reporter.test(fileName + 'Test.ts', testName, testCount);
            return test.start()
                .then(function () { return test.skip(skippedMessage); })
                .then(function () {
                assert.equal(endTestData.length, 1);
                var data = endTestData[0];
                assert.equal(data.session, sessionId);
                assert.equal(data.file, fileName + 'Test.ts');
                assert.equal(data.name, testName);
                assert.isFalse(data.passed);
                assert.equal(data.skipped, skippedMessage);
                assert.isNull(data.error);
                assert.isString(data.time);
                assert.deepEqual(reporter.summary(), {
                    offset: offset,
                    passed: offset,
                    failed: 0,
                    skipped: 1
                }, 'Summary has one skipped test');
                assert.isFalse(doneCalled);
            });
        }));
    });
    it('should report the session id, file, name, passed state, time and error on a test failure', function () {
        return fc.assert(fc.asyncProperty(fc.hexaString(), fc.asciiString(), fc.integer(offset), function (fileName, testName, testCount) {
            reset();
            var test = reporter.test(fileName + 'Test.ts', testName, testCount);
            var error = LoggedError.loggedError(new Error('Failed'), ['Log Message']);
            return test.start()
                .then(function () { return test.fail(error); })
                .then(function () {
                var _a;
                assert.equal(endTestData.length, 1);
                var data = endTestData[0];
                assert.equal(data.session, sessionId);
                assert.equal(data.file, fileName + 'Test.ts');
                assert.equal(data.name, testName);
                assert.isFalse(data.passed);
                assert.isNull(data.skipped);
                assert.isString(data.time);
                assert.equal((_a = data.error) === null || _a === void 0 ? void 0 : _a.text, 'Error: Failed\n\nLogs:\nLog Message');
                assert.deepEqual(reporter.summary(), {
                    offset: offset,
                    passed: offset,
                    failed: 1,
                    skipped: 0
                }, 'Summary has one failed test');
                assert.isFalse(doneCalled);
            });
        }));
    });
    it('should report done', function () {
        reporter.done();
        assert.isTrue(doneCalled);
        assert.isUndefined(doneError);
    });
    it('should report done with an error', function () {
        reporter.done(Failure.prepFailure('Unexpected error occurred'));
        assert.isTrue(doneCalled);
        assert.include(doneError, 'Unexpected error occurred');
    });
});
//# sourceMappingURL=ReporterTest.js.map