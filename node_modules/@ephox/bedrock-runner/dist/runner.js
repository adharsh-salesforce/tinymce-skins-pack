(function () {
    'use strict';

    var isLoggedError = function (error) {
        return typeof error === 'object' && Object.prototype.hasOwnProperty.call(error, 'logs');
    };
    var loggedError = function (error, logs) {
        var logged = error;
        logged.logs = logs;
        return logged;
    };

    function Diff() {}
    Diff.prototype = {
      diff: function diff(oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var callback = options.callback;

        if (typeof options === 'function') {
          callback = options;
          options = {};
        }

        this.options = options;
        var self = this;

        function done(value) {
          if (callback) {
            setTimeout(function () {
              callback(undefined, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        } // Allow subclasses to massage the input prior to running


        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length,
            oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }]; // Seed editLength = 0, i.e. the content starts with the same values

        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          // Identity per the equality and tokenizer
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        } // Main worker method. checks all permutations of a given edit length for acceptance.


        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = void 0;

            var addPath = bestPath[diagonalPath - 1],
                removePath = bestPath[diagonalPath + 1],
                _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

            if (addPath) {
              // No one else is going to attempt to use this value, clear it
              bestPath[diagonalPath - 1] = undefined;
            }

            var canAdd = addPath && addPath.newPos + 1 < newLen,
                canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

            if (!canAdd && !canRemove) {
              // If this path is a terminal then prune
              bestPath[diagonalPath] = undefined;
              continue;
            } // Select the diagonal that we want to branch from. We select the prior
            // path whose position in the new string is the farthest from the origin
            // and does not pass the bounds of the diff graph


            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self.pushComponent(basePath.components, undefined, true);
            } else {
              basePath = addPath; // No need to clone, we've pulled it from the list

              basePath.newPos++;
              self.pushComponent(basePath.components, true, undefined);
            }

            _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
            } else {
              // Otherwise track this path as a potential candidate and continue.
              bestPath[diagonalPath] = basePath;
            }
          }

          editLength++;
        } // Performs the length of edit iteration. Is a bit fugly as this has to support the
        // sync and async mode which is never fun. Loops over execEditLength until a value
        // is produced.


        if (callback) {
          (function exec() {
            setTimeout(function () {
              // This should not happen, but we want to be safe.

              /* istanbul ignore next */
              if (editLength > maxEditLength) {
                return callback();
              }

              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();

            if (ret) {
              return ret;
            }
          }
        }
      },
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];

        if (last && last.added === added && last.removed === removed) {
          // We need to clone here as the component clone operation is just
          // as shallow array clone
          components[components.length - 1] = {
            count: last.count + 1,
            added: added,
            removed: removed
          };
        } else {
          components.push({
            count: 1,
            added: added,
            removed: removed
          });
        }
      },
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length,
            oldLen = oldString.length,
            newPos = basePath.newPos,
            oldPos = newPos - diagonalPath,
            commonCount = 0;

        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }

        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }

        basePath.newPos = newPos;
        return oldPos;
      },
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      removeEmpty: function removeEmpty(array) {
        var ret = [];

        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }

        return ret;
      },
      castInput: function castInput(value) {
        return value;
      },
      tokenize: function tokenize(value) {
        return value.split('');
      },
      join: function join(chars) {
        return chars.join('');
      }
    };

    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0,
          componentLen = components.length,
          newPos = 0,
          oldPos = 0;

      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];

        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function (value, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value.length ? oldValue : value;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }

          newPos += component.count; // Common case

          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
          // The diffing algorithm is tied to add then remove output and this is the simplest
          // route to get the desired output with minimal overhead.

          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      } // Special case handle for when one terminal is ignored (i.e. whitespace).
      // For this case we merge the terminal into the prior string and drop the change.
      // This is only available for string mode.


      var lastComponent = components[componentLen - 1];

      if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }

      return components;
    }

    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }

    //
    // Ranges and exceptions:
    // Latin-1 Supplement, 0080–00FF
    //  - U+00D7  × Multiplication sign
    //  - U+00F7  ÷ Division sign
    // Latin Extended-A, 0100–017F
    // Latin Extended-B, 0180–024F
    // IPA Extensions, 0250–02AF
    // Spacing Modifier Letters, 02B0–02FF
    //  - U+02C7  ˇ &#711;  Caron
    //  - U+02D8  ˘ &#728;  Breve
    //  - U+02D9  ˙ &#729;  Dot Above
    //  - U+02DA  ˚ &#730;  Ring Above
    //  - U+02DB  ˛ &#731;  Ogonek
    //  - U+02DC  ˜ &#732;  Small Tilde
    //  - U+02DD  ˝ &#733;  Double Acute Accent
    // Latin Extended Additional, 1E00–1EFF

    var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    var reWhitespace = /\S/;
    var wordDiff = new Diff();

    wordDiff.equals = function (left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }

      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };

    wordDiff.tokenize = function (value) {
      // All whitespace symbols except newline group into one token, each newline - in separate token
      var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

      for (var i = 0; i < tokens.length - 1; i++) {
        // If we have an empty string in the next field and we have only word chars before and after, merge
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }

      return tokens;
    };

    var lineDiff = new Diff();

    lineDiff.tokenize = function (value) {
      var retLines = [],
          linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      } // Merge the content and line separators into single tokens


      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];

        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }

          retLines.push(line);
        }
      }

      return retLines;
    };

    var sentenceDiff = new Diff();

    sentenceDiff.tokenize = function (value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };

    var cssDiff = new Diff();

    cssDiff.tokenize = function (value) {
      return value.split(/([{}:;,]|\s+)/);
    };

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    var objectPrototypeToString = Object.prototype.toString;
    var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
    // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = lineDiff.tokenize;

    jsonDiff.castInput = function (value) {
      var _this$options = this.options,
          undefinedReplacement = _this$options.undefinedReplacement,
          _this$options$stringi = _this$options.stringifyReplacer,
          stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
        return typeof v === 'undefined' ? undefinedReplacement : v;
      } : _this$options$stringi;
      return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
    };

    jsonDiff.equals = function (left, right) {
      return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
    };
    // object that is already on the "stack" of items being processed. Accepts an optional replacer

    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];

      if (replacer) {
        obj = replacer(key, obj);
      }

      var i;

      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }

      var canonicalizedObj;

      if ('[object Array]' === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);

        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }

        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }

      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }

      if (_typeof(obj) === 'object' && obj !== null) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);

        var sortedKeys = [],
            _key;

        for (_key in obj) {
          /* istanbul ignore else */
          if (obj.hasOwnProperty(_key)) {
            sortedKeys.push(_key);
          }
        }

        sortedKeys.sort();

        for (i = 0; i < sortedKeys.length; i += 1) {
          _key = sortedKeys[i];
          canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
        }

        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }

      return canonicalizedObj;
    }

    var arrayDiff = new Diff();

    arrayDiff.tokenize = function (value) {
      return value.slice();
    };

    arrayDiff.join = arrayDiff.removeEmpty = function (value) {
      return value;
    };

    function diffArrays(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }

    var htmlentities = function (str) {
        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    };

    var diffPrettyHtml = function (text1, text2) {
        var changes = diffArrays(text1.split('\n'), text2.split('\n'));
        var lines = changes.map(function (c) {
            var prefix = (c.removed ? '<del style="background:#ffe6e6;">' : c.added ? '<ins style="background:#e6ffe6;">' : '<span>');
            var suffix = (c.removed ? '</del>' : c.added ? '</ins>' : '</span>');
            var texts = c.value;
            var tz = texts.map(function (t) { return prefix + htmlentities(t) + suffix + '<br />'; });
            return tz.join('');
        });
        return lines.join('');
    };
    var diffPrettyText = function (text1, text2) {
        var changes = diffArrays(text1.split('\n'), text2.split('\n'));
        var lines = changes.map(function (c) {
            var prefix = (c.removed ? '-' : c.added ? '+' : ' ') + ' | ';
            var texts = c.value;
            return prefix + texts.join('\n' + prefix);
        });
        return lines.join('\n');
    };

    var __assign = (window && window.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var stringify = function (e) {
        if (e === undefined) {
            return 'undefined';
        }
        else if (typeof e === 'string') {
            return e;
        }
        else {
            return JSON.stringify(e);
        }
    };
    var extractError = function (err) {
        return err === undefined ? new Error('no error given') : err;
    };
    var extractStack = function (e) {
        if (e.stack) {
            return e.stack.split('\n')
                .filter(function (line) { return line.indexOf('at') !== -1; })
                .join('\n');
        }
        else {
            return '';
        }
    };
    var extractErrorData = function (e) {
        var actual = e.diff.actual;
        var expected = e.diff.expected;
        var comparison = isHTMLDiffError(e) ? e.diff.comparison : diffPrettyText(actual, expected);
        return ({
            type: e.name,
            message: "Test failure: ".concat(e.message),
            diff: {
                actual: actual,
                expected: expected,
                comparison: comparison
            }
        });
    };
    var extractAssertionErrorData = function (e) {
        var _a;
        var actual = stringify(e.actual);
        var expected = stringify(e.expected);
        var message = "Assertion error: ".concat((_a = e.message) !== null && _a !== void 0 ? _a : '');
        if (e.showDiff !== false) {
            return {
                type: e.name,
                message: message,
                diff: {
                    expected: expected,
                    actual: actual,
                    comparison: diffPrettyText(actual, expected)
                }
            };
        }
        else {
            return { type: e.name, message: message };
        }
    };
    var getBasicErrorData = function (e) {
        if (isHTMLDiffError(e) || isPprintAssertionError(e)) {
            return extractErrorData(e);
        }
        else if (isAssertionError(e)) {
            return extractAssertionErrorData(e);
        }
        else if (e.name && e.message) {
            return { type: 'Error', message: e.name + ': ' + e.message };
        }
        else if (e.toString !== undefined) {
            return { type: 'Error', message: String(e) };
        }
        else {
            return { type: 'Error', message: JSON.stringify(e) };
        }
    };
    var getErrorData = function (err) {
        var e = extractError(err);
        var formattedLogs = err.logs && err.logs.length > 0 ? err.logs.map(function (log) { return log
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r'); }).join('\n') : undefined;
        return __assign(__assign({}, getBasicErrorData(e)), { stack: extractStack(e), logs: formattedLogs });
    };

    var identity = function (val) { return val; };
    /* Required to make <del> and <ins> stay as tags.*/
    var processQUnit = function (html) {
        return (html
            .replace(/&lt;del&gt;/g, '<del>')
            .replace(/&lt;\/del&gt;/g, '</del>')
            .replace(/&lt;ins&gt;/g, '<ins>')
            .replace(/&lt;\/ins&gt;/g, '</ins>'));
    };
    var pprintExtra = function (e) {
        if (e.logs !== undefined && e.logs.length > 0) {
            return "\n\nLogs:\n".concat(e.logs);
        }
        else if (e.stack !== undefined && e.stack.length > 0) {
            return "\n\nStack:\n".concat(e.stack);
        }
        else {
            return '';
        }
    };
    var pprintDiff = function (e, escape, diff) {
        if (e.diff) {
            var comparison = e.type === 'HtmlAssertion' ? escape(e.diff.comparison) : undefined;
            var dh = diff(e.diff.actual, e.diff.expected, comparison);
            return "Expected:\n".concat(escape(e.diff.expected), "\nActual:\n").concat(escape(e.diff.actual), "\nDiff:\n").concat(dh);
        }
        else {
            return '';
        }
    };
    var pprintBasicError = function (e, escape, diff) {
        var message = escape(e.message);
        var diffMessage = pprintDiff(e, escape, diff);
        if (diffMessage.length > 0) {
            return "".concat(message, "\n").concat(diffMessage);
        }
        else {
            return message;
        }
    };
    var pprintError = function (e, escape, diff) {
        var message = pprintBasicError(e, escape, diff);
        var extras = escape(pprintExtra(e));
        return "".concat(message).concat(extras);
    };
    var data = function (err) {
        return getErrorData(err);
    };
    var dataHtml = function (err) {
        return pprintError(err, htmlentities, function (actual, expected, comparison) {
            return comparison !== undefined ? processQUnit(comparison) : diffPrettyHtml(actual, expected);
        });
    };
    var dataText = function (err) {
        return pprintError(err, identity, function (actual, expected, comparison) {
            // TODO: get rid of the <ins> and <del> in the comparison. Probably need to change the code that throws HtmlAssertionError.
            return comparison !== undefined ? comparison : diffPrettyText(actual, expected);
        });
    };
    var html = function (err) {
        var e = getErrorData(err);
        return dataHtml(e);
    };
    var text = function (err) {
        var e = getErrorData(err);
        return dataText(e);
    };

    var isPprintAssertionError = function (err) {
        return err.name === 'PprintAssertionError';
    };
    var isHTMLDiffError = function (err) {
        return err.name === 'HtmlAssertion';
    };
    var isAssertionError = function (err) {
        return err.name === 'AssertionError';
    };

    var TestLogEntryState;
    (function (TestLogEntryState) {
        TestLogEntryState[TestLogEntryState["Original"] = 0] = "Original";
        TestLogEntryState[TestLogEntryState["Started"] = 1] = "Started";
        TestLogEntryState[TestLogEntryState["Finished"] = 2] = "Finished";
    })(TestLogEntryState || (TestLogEntryState = {}));
    var init = function () { return ({
        history: []
    }); };

    var cleanStack = function (error, linesToRemove) {
        if (linesToRemove === void 0) { linesToRemove = 1; }
        if (error.stack === undefined) {
            return '';
        }
        var lines = error.stack.split('\n');
        var message = lines[0];
        // If the first line is the `normalizeError` function then we have no message (e.g. Firefox errors)
        if (message.indexOf('normalizeError') !== -1) {
            var stack = lines.slice(linesToRemove);
            return stack.join('\n');
        }
        else {
            var stack = lines.slice(1 + linesToRemove);
            return message + '\n' + stack.join('\n');
        }
    };
    var normalizeError = function (err) {
        if (typeof err === 'string') {
            // Create an error object, but strip the stack of the 2 latest calls as it'll
            // just be this function and the previous function that called this (ie asyncTest)
            var error = new Error(err);
            error.stack = cleanStack(error, 2);
            return error;
        }
        else if (typeof err === 'function') {
            return normalizeError(err());
        }
        else if (isAssertionError(err)) {
            // Chai assertion errors are objects, but we want an actual error
            // so it prints better in the console
            var error_1 = new Error(err.message);
            error_1.name = err.name;
            error_1.stack = err.stack;
            var keys = Object.keys(err);
            keys.forEach(function (key) {
                error_1[key] = err[key];
            });
            return error_1;
        }
        else {
            return err;
        }
    };
    var processLog = function (logs) {
        var outputToStr = function (numIndent, entries) {
            var everything = [];
            var indentString = '';
            for (var i = 0; i < numIndent; i++) {
                indentString += ' ';
            }
            var _loop_1 = function (i) {
                var entry = entries[i];
                var output = (function () {
                    var traceLines = entry.trace === null || typeof entry.trace !== 'string' ? [] : ['', ''].concat(entry.trace.split('\n'));
                    if (entry.entries.length === 0) {
                        if (entry.trace === null) {
                            return [indentString + '*  ' + entry.message];
                        }
                        else {
                            return [indentString + '*  ' + entry.message].concat(traceLines);
                        }
                    }
                    else {
                        // We have entries ... let's format them.
                        return [indentString + '*  ' + entry.message].concat(outputToStr(numIndent + 2, entry.entries)).concat(traceLines);
                    }
                })();
                everything = everything.concat(output);
            };
            for (var i = 0; i < entries.length; i++) {
                _loop_1(i);
            }
            return everything;
        };
        return outputToStr(2, logs.history);
    };
    var prepFailure = function (err, logs) {
        if (logs === void 0) { logs = init(); }
        if (isLoggedError(err)) {
            return err;
        }
        else {
            var normalizedErr = normalizeError(err);
            var failureMessage = processLog(logs);
            return loggedError(normalizedErr, failureMessage);
        }
    };

    var Global = (function () {
        if (typeof window !== 'undefined') {
            return window;
        }
        else {
            return Function('return this;')();
        }
    })();

    var typeOf = function (x) {
        if (x === null) {
            return 'null';
        }
        var t = typeof x;
        if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
            return 'array';
        }
        if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
            return 'string';
        }
        return t;
    };
    var isType = function (type) { return function (value) {
        return typeOf(value) === type;
    }; };
    var isString = isType('string');
    // eslint-disable-next-line @typescript-eslint/ban-types
    var isObject = isType('object');

    var exports$1 = {}, module = { exports: exports$1 };
    (function(define, exports, module, require) {(function (global, factory) {
    	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    	typeof define === 'function' && define.amd ? define(factory) :
    	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.EphoxContactWrapper = factory());
    }(this, (function () {
    	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    	var promise = {exports: {}};

    	(function (module) {
    	(function (root) {

    	  // Store setTimeout reference so promise-polyfill will be unaffected by
    	  // other code modifying setTimeout (like sinon.useFakeTimers())
    	  var setTimeoutFunc = setTimeout;

    	  function noop() {}
    	  
    	  // Polyfill for Function.prototype.bind
    	  function bind(fn, thisArg) {
    	    return function () {
    	      fn.apply(thisArg, arguments);
    	    };
    	  }

    	  function Promise(fn) {
    	    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    	    if (typeof fn !== 'function') throw new TypeError('not a function');
    	    this._state = 0;
    	    this._handled = false;
    	    this._value = undefined;
    	    this._deferreds = [];

    	    doResolve(fn, this);
    	  }

    	  function handle(self, deferred) {
    	    while (self._state === 3) {
    	      self = self._value;
    	    }
    	    if (self._state === 0) {
    	      self._deferreds.push(deferred);
    	      return;
    	    }
    	    self._handled = true;
    	    Promise._immediateFn(function () {
    	      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    	      if (cb === null) {
    	        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
    	        return;
    	      }
    	      var ret;
    	      try {
    	        ret = cb(self._value);
    	      } catch (e) {
    	        reject(deferred.promise, e);
    	        return;
    	      }
    	      resolve(deferred.promise, ret);
    	    });
    	  }

    	  function resolve(self, newValue) {
    	    try {
    	      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
    	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
    	        var then = newValue.then;
    	        if (newValue instanceof Promise) {
    	          self._state = 3;
    	          self._value = newValue;
    	          finale(self);
    	          return;
    	        } else if (typeof then === 'function') {
    	          doResolve(bind(then, newValue), self);
    	          return;
    	        }
    	      }
    	      self._state = 1;
    	      self._value = newValue;
    	      finale(self);
    	    } catch (e) {
    	      reject(self, e);
    	    }
    	  }

    	  function reject(self, newValue) {
    	    self._state = 2;
    	    self._value = newValue;
    	    finale(self);
    	  }

    	  function finale(self) {
    	    if (self._state === 2 && self._deferreds.length === 0) {
    	      Promise._immediateFn(function() {
    	        if (!self._handled) {
    	          Promise._unhandledRejectionFn(self._value);
    	        }
    	      });
    	    }

    	    for (var i = 0, len = self._deferreds.length; i < len; i++) {
    	      handle(self, self._deferreds[i]);
    	    }
    	    self._deferreds = null;
    	  }

    	  function Handler(onFulfilled, onRejected, promise) {
    	    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    	    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    	    this.promise = promise;
    	  }

    	  /**
    	   * Take a potentially misbehaving resolver function and make sure
    	   * onFulfilled and onRejected are only called once.
    	   *
    	   * Makes no guarantees about asynchrony.
    	   */
    	  function doResolve(fn, self) {
    	    var done = false;
    	    try {
    	      fn(function (value) {
    	        if (done) return;
    	        done = true;
    	        resolve(self, value);
    	      }, function (reason) {
    	        if (done) return;
    	        done = true;
    	        reject(self, reason);
    	      });
    	    } catch (ex) {
    	      if (done) return;
    	      done = true;
    	      reject(self, ex);
    	    }
    	  }

    	  Promise.prototype['catch'] = function (onRejected) {
    	    return this.then(null, onRejected);
    	  };

    	  Promise.prototype.then = function (onFulfilled, onRejected) {
    	    var prom = new (this.constructor)(noop);

    	    handle(this, new Handler(onFulfilled, onRejected, prom));
    	    return prom;
    	  };

    	  Promise.all = function (arr) {
    	    var args = Array.prototype.slice.call(arr);

    	    return new Promise(function (resolve, reject) {
    	      if (args.length === 0) return resolve([]);
    	      var remaining = args.length;

    	      function res(i, val) {
    	        try {
    	          if (val && (typeof val === 'object' || typeof val === 'function')) {
    	            var then = val.then;
    	            if (typeof then === 'function') {
    	              then.call(val, function (val) {
    	                res(i, val);
    	              }, reject);
    	              return;
    	            }
    	          }
    	          args[i] = val;
    	          if (--remaining === 0) {
    	            resolve(args);
    	          }
    	        } catch (ex) {
    	          reject(ex);
    	        }
    	      }

    	      for (var i = 0; i < args.length; i++) {
    	        res(i, args[i]);
    	      }
    	    });
    	  };

    	  Promise.resolve = function (value) {
    	    if (value && typeof value === 'object' && value.constructor === Promise) {
    	      return value;
    	    }

    	    return new Promise(function (resolve) {
    	      resolve(value);
    	    });
    	  };

    	  Promise.reject = function (value) {
    	    return new Promise(function (resolve, reject) {
    	      reject(value);
    	    });
    	  };

    	  Promise.race = function (values) {
    	    return new Promise(function (resolve, reject) {
    	      for (var i = 0, len = values.length; i < len; i++) {
    	        values[i].then(resolve, reject);
    	      }
    	    });
    	  };

    	  // Use polyfill for setImmediate for performance gains
    	  Promise._immediateFn = (
    	    typeof setImmediate === 'function' 
    	    ? function (fn) { setImmediate(fn); }
    	    : function (fn) { setTimeoutFunc(fn, 0); }
    	  );

    	  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    	    if (typeof console !== 'undefined' && console) {
    	      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    	    }
    	  };

    	  /**
    	   * Set the immediate function to execute callbacks
    	   * @param fn {function} Function to execute
    	   * @deprecated
    	   */
    	  Promise._setImmediateFn = function _setImmediateFn(fn) {
    	    Promise._immediateFn = fn;
    	  };

    	  /**
    	   * Change the function to execute on unhandled rejection
    	   * @param {function} fn Function to execute on unhandled rejection
    	   * @deprecated
    	   */
    	  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    	    Promise._unhandledRejectionFn = fn;
    	  };
    	  
    	  if (module.exports) {
    	    module.exports = Promise;
    	  } else if (!root.Promise) {
    	    root.Promise = Promise;
    	  }

    	})(commonjsGlobal);
    	}(promise));

    	var promisePolyfill = promise.exports;
    	var Global = (function() {
    	  // Use window object as the global if it's available since CSP will block script evals
    	  if (typeof window !== 'undefined') {
    	    return window;
    	  } else {
    	    return Function('return this;')();
    	  }
    	})();
    	var promisePolyfill_1 = {
    	  boltExport: Global.Promise || promisePolyfill
    	};

    	return promisePolyfill_1;

    })));
    })(undefined, exports$1, module);
    var Promise = module.exports.boltExport;

    var __extends = (window && window.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var SkipError = /** @class */ (function (_super) {
        __extends(SkipError, _super);
        function SkipError(message) {
            var _this = _super.call(this, message) || this;
            // Set the prototype explicitly.
            Object.setPrototypeOf(_this, SkipError.prototype);
            return _this;
        }
        return SkipError;
    }(Error));
    var MultipleDone = /** @class */ (function (_super) {
        __extends(MultipleDone, _super);
        function MultipleDone(message, original) {
            var _this = _super.call(this, message) || this;
            _this.original = original;
            // Set the prototype explicitly.
            Object.setPrototypeOf(_this, MultipleDone.prototype);
            return _this;
        }
        return MultipleDone;
    }(Error));
    var isInternalError = function (err) {
        return err instanceof SkipError || err instanceof MultipleDone;
    };

    var createRunnable = function (title, fn) {
        var retries = -1;
        var timeout = -1;
        var slow = 75;
        var state = "notrun" /* NotRun */;
        var listeners = {};
        var fireChange = function (type, value) {
            if (listeners.hasOwnProperty(type)) {
                listeners[type].forEach(function (listener) {
                    listener(value);
                });
            }
        };
        var runnable = {
            fn: fn,
            title: title,
            isFailed: function () { return state === "failed" /* Failed */; },
            isSkipped: function () { return state === "skipped" /* Skipped */; },
            isPassed: function () { return state === "passed" /* Passed */; },
            setResult: function (s, e) {
                state = s;
                runnable.error = e;
            },
            skip: function () {
                throw new SkipError('skip manually called');
            },
            retries: function (retry) {
                if (retry !== undefined) {
                    fireChange('retries', retry);
                    retries = retry;
                    return runnable;
                }
                else {
                    return retries;
                }
            },
            slow: function (ms) {
                if (ms !== undefined) {
                    fireChange('slow', ms);
                    slow = ms;
                    return runnable;
                }
                else {
                    return slow;
                }
            },
            timeout: function (ms) {
                if (ms !== undefined) {
                    fireChange('timeout', ms);
                    timeout = ms;
                    return runnable;
                }
                else {
                    return timeout;
                }
            },
            _onChange: function (type, callback) {
                if (!listeners.hasOwnProperty(type)) {
                    listeners[type] = new Set();
                }
                listeners[type].add(callback);
                return function () {
                    listeners[type].delete(callback);
                };
            }
        };
        return runnable;
    };

    var createHook = function (title, fn) {
        return createRunnable(title, fn);
    };

    var isMarked = function (test) {
        return test.__registered === true;
    };
    var mark = function (test) {
        test.__registered = true;
    };
    var test = function (test) {
        if (typeof Global.__tests === 'undefined') {
            Global.__tests = [];
        }
        // Mark the test to ensure we don't register it twice
        if (!isMarked(test)) {
            mark(test);
            Global.__tests.push(test);
        }
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var sourcemappedStacktrace = createCommonjsModule(function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(commonjsGlobal, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};

    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {

    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId])
    /******/ 			return installedModules[moduleId].exports;

    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			exports: {},
    /******/ 			id: moduleId,
    /******/ 			loaded: false
    /******/ 		};

    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    /******/ 		// Flag the module as loaded
    /******/ 		module.loaded = true;

    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}


    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;

    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;

    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";

    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(0);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {

    	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
    	 * sourcemapped-stacktrace.js
    	 * created by James Salter <iteration@gmail.com> (2014)
    	 *
    	 * https://github.com/novocaine/sourcemapped-stacktrace
    	 *
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	/*global define */

    	// note we only include source-map-consumer, not the whole source-map library,
    	// which includes gear for generating source maps that we don't need
    	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(source_map_consumer) {

    	  var global_mapForUri = {};

    	  /**
    	   * Re-map entries in a stacktrace using sourcemaps if available.
    	   *
    	   * @param {str} stack - The stacktrace from the browser.
    	   * @param {function} done - Callback invoked with the transformed stacktrace
    	   *                          (an Array of Strings) passed as the first
    	   *                          argument
    	   * @param {Object} [opts] - Optional options object.
    	   * @param {Function} [opts.filter] - Filter function applied to each stackTrace line.
    	   *                                   Lines which do not pass the filter won't be processesd.
    	   * @param {boolean} [opts.cacheGlobally] - Whether to cache sourcemaps globally across multiple calls.
    	   * @param {boolean} [opts.sync] - Whether to use synchronous ajax to load the sourcemaps.
    	   * @param {string} [opts.traceFormat] - If `error.stack` is formatted according to chrome or
    	   *                                      Firefox's style.  Can be either `"chrome"`, `"firefox"`
    	   *                                      or `undefined` (default).  If `undefined`, this library
    	   *                                      will guess based on `navigator.userAgent`.
    	   */
    	  var mapStackTrace = function(stack, done, opts) {
    	    var lines;
    	    var line;
    	    var rows = {};
    	    var fields;
    	    var uri;
    	    var expected_fields;
    	    var regex;

    	    var fetcher = new Fetcher(opts);

    	    var traceFormat = opts && opts.traceFormat;
    	    if (traceFormat !== "chrome" && traceFormat !== "firefox") {
    	      if (traceFormat) {
    	        throw new Error("unknown traceFormat \"" + traceFormat + "\" :(");
    	      } else if (isChromeOrEdge() || isIE11Plus()) {
    	        traceFormat = "chrome";
    	      } else if (isFirefox() || isSafari()) {
    	        traceFormat = "firefox";
    	      } else {
    	        throw new Error("unknown browser :(");
    	      }
    	    }

    	    if (traceFormat === "chrome") {
    	      regex = /^ +at.+(https?:\/\/.*):([0-9]+):([0-9]+)/;
    	      expected_fields = 4;
    	    } else {
    	      regex = /@(https?:\/\/.*):([0-9]+):([0-9]+)/;
    	      expected_fields = 4;
    	    }

    	    lines = stack.split("\n");

    	    for (var i=0; i < lines.length; i++) {
    	      line = lines[i];
    	      if ( opts && opts.filter && !opts.filter(line) ) continue;
    	      
    	      fields = line.match(regex);
    	      if (fields && fields.length === expected_fields) {
    	        rows[i] = fields;
    	        uri = fields[1];
    	        if (!uri.match(/<anonymous>/)) {
    	          fetcher.fetchScript(uri);
    	        }
    	      }
    	    }

    	    fetcher.sem.whenReady(function() {
    	      var result = processSourceMaps(lines, rows, fetcher.mapForUri, traceFormat);
    	      done(result);
    	    });
    	  };

    	  var isChromeOrEdge = function() {
    	    return navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
    	  };

    	  var isFirefox = function() {
    	    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    	  };  

    	  var isSafari = function() {
    	    return navigator.userAgent.toLowerCase().indexOf('safari') > -1;
    	  };
    			
    	  var isIE11Plus = function() {
    	   	return document.documentMode && document.documentMode >= 11;
    	  };


    	  var Semaphore = function() {
    	    this.count = 0;
    	    this.pending = [];
    	  };

    	  Semaphore.prototype.incr = function() {
    	    this.count++;
    	  };

    	  Semaphore.prototype.decr = function() {
    	    this.count--;
    	    this.flush();
    	  };

    	  Semaphore.prototype.whenReady = function(fn) {
    	    this.pending.push(fn);
    	    this.flush();
    	  };

    	  Semaphore.prototype.flush = function() {
    	    if (this.count === 0) {
    	        this.pending.forEach(function(fn) { fn(); });
    	        this.pending = [];
    	    }
    	  };


    	  var Fetcher = function(opts) {
    	    this.sem = new Semaphore();
    	    this.sync = opts && opts.sync;
    	    this.mapForUri = opts && opts.cacheGlobally ? global_mapForUri : {};
    	  };

    	  Fetcher.prototype.ajax = function(uri, callback) {
    	    var xhr = createXMLHTTPObject();
    	    var that = this;
    	    xhr.onreadystatechange = function() {
    	      if (xhr.readyState == 4) {
    	        callback.call(that, xhr, uri);
    	      }
    	    };
    	    xhr.open("GET", uri, !this.sync);
    	    xhr.send();
    	  };

    	  Fetcher.prototype.fetchScript = function(uri) {
    	    if (!(uri in this.mapForUri)) {
    	      this.sem.incr();
    	      this.mapForUri[uri] = null;
    	    } else {
    	      return;
    	    }

    	    this.ajax(uri, this.onScriptLoad);
    	  };

    	  var absUrlRegex = new RegExp('^(?:[a-z]+:)?//', 'i');

    	  Fetcher.prototype.onScriptLoad = function(xhr, uri) {
    	    if (xhr.status === 200 || (uri.slice(0, 7) === "file://" && xhr.status === 0)) {
    	      // find .map in file.
    	      //
    	      // attempt to find it at the very end of the file, but tolerate trailing
    	      // whitespace inserted by some packers.
    	      var match = xhr.responseText.match("//# [s]ourceMappingURL=(.*)[\\s]*$", "m");
    	      if (match && match.length === 2) {
    	        // get the map
    	        var mapUri = match[1];

    	        var embeddedSourceMap = mapUri.match("data:application/json;(charset=[^;]+;)?base64,(.*)");

    	        if (embeddedSourceMap && embeddedSourceMap[2]) {
    	          this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(atob(embeddedSourceMap[2]));
    	          this.sem.decr();
    	        } else {
    	          if (!absUrlRegex.test(mapUri)) {
    	            // relative url; according to sourcemaps spec is 'source origin'
    	            var origin;
    	            var lastSlash = uri.lastIndexOf('/');
    	            if (lastSlash !== -1) {
    	              origin = uri.slice(0, lastSlash + 1);
    	              mapUri = origin + mapUri;
    	              // note if lastSlash === -1, actual script uri has no slash
    	              // somehow, so no way to use it as a prefix... we give up and try
    	              // as absolute
    	            }
    	          }

    	          this.ajax(mapUri, function(xhr) {
    	            if (xhr.status === 200 || (mapUri.slice(0, 7) === "file://" && xhr.status === 0)) {
    	              this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(xhr.responseText);
    	            }
    	            this.sem.decr();
    	          });
    	        }
    	      } else {
    	        // no map
    	        this.sem.decr();
    	      }
    	    } else {
    	      // HTTP error fetching uri of the script
    	      this.sem.decr();
    	    }
    	  };

    	  var processSourceMaps = function(lines, rows, mapForUri, traceFormat) {
    	    var result = [];
    	    var map;
    	    var origName = traceFormat === "chrome" ? origNameChrome : origNameFirefox;
    	    for (var i=0; i < lines.length; i++) {
    	      var row = rows[i];
    	      if (row) {
    	        var uri = row[1];
    	        var line = parseInt(row[2], 10);
    	        var column = parseInt(row[3], 10);
    	        map = mapForUri[uri];

    	        if (map) {
    	          // we think we have a map for that uri. call source-map library
    	          var origPos = map.originalPositionFor(
    	            { line: line, column: column });
    	          result.push(formatOriginalPosition(origPos.source,
    	            origPos.line, origPos.column, origPos.name || origName(lines[i])));
    	        } else {
    	          // we can't find a map for that url, but we parsed the row.
    	          // reformat unchanged line for consistency with the sourcemapped
    	          // lines.
    	          result.push(formatOriginalPosition(uri, line, column, origName(lines[i])));
    	        }
    	      } else {
    	        // we weren't able to parse the row, push back what we were given
    	        result.push(lines[i]);
    	      }
    	    }

    	    return result;
    	  };

    	  function origNameChrome(origLine) {
    	    var match = / +at +([^ ]*).*\(/.exec(origLine);
    	    return match && match[1];
    	  }

    	  function origNameFirefox(origLine) {
    	    var match = /([^@]*?)(\/<)*@.*/.exec(origLine);
    	    return match && match[1];
    	  }

    	  var formatOriginalPosition = function(source, line, column, name) {
    	    // mimic chrome's format
    			if (name) {
    				return "    at " + name + " (" + source + ":" + line + ":" + column + ")";
    			} else {
    				return "    at " + source + ":" + line + ":" + column;
    			}
    	  };

    	  // xmlhttprequest boilerplate
    	  var XMLHttpFactories = [
    		function () {return new XMLHttpRequest();},
    		function () {return new ActiveXObject("Msxml2.XMLHTTP");},
    		function () {return new ActiveXObject("Msxml3.XMLHTTP");},
    		function () {return new ActiveXObject("Microsoft.XMLHTTP");}
    	  ];

    	  function createXMLHTTPObject() {
    	      var xmlhttp = false;
    	      for (var i=0;i<XMLHttpFactories.length;i++) {
    	          try {
    	              xmlhttp = XMLHttpFactories[i]();
    	          }
    	          catch (e) {
    	              continue;
    	          }
    	          break;
    	      }
    	      return xmlhttp;
    	  }

    	  return {
    	    mapStackTrace: mapStackTrace
    	  }
    	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {

    	/* -*- Mode: js; js-indent-level: 2; -*- */
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	var util = __webpack_require__(2);
    	var binarySearch = __webpack_require__(3);
    	var ArraySet = __webpack_require__(4).ArraySet;
    	var base64VLQ = __webpack_require__(5);
    	var quickSort = __webpack_require__(7).quickSort;

    	function SourceMapConsumer(aSourceMap) {
    	  var sourceMap = aSourceMap;
    	  if (typeof aSourceMap === 'string') {
    	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    	  }

    	  return sourceMap.sections != null
    	    ? new IndexedSourceMapConsumer(sourceMap)
    	    : new BasicSourceMapConsumer(sourceMap);
    	}

    	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
    	};

    	/**
    	 * The version of the source mapping spec that we are consuming.
    	 */
    	SourceMapConsumer.prototype._version = 3;

    	// `__generatedMappings` and `__originalMappings` are arrays that hold the
    	// parsed mapping coordinates from the source map's "mappings" attribute. They
    	// are lazily instantiated, accessed via the `_generatedMappings` and
    	// `_originalMappings` getters respectively, and we only parse the mappings
    	// and create these arrays once queried for a source location. We jump through
    	// these hoops because there can be many thousands of mappings, and parsing
    	// them is expensive, so we only want to do it if we must.
    	//
    	// Each object in the arrays is of the form:
    	//
    	//     {
    	//       generatedLine: The line number in the generated code,
    	//       generatedColumn: The column number in the generated code,
    	//       source: The path to the original source file that generated this
    	//               chunk of code,
    	//       originalLine: The line number in the original source that
    	//                     corresponds to this chunk of generated code,
    	//       originalColumn: The column number in the original source that
    	//                       corresponds to this chunk of generated code,
    	//       name: The name of the original symbol which generated this chunk of
    	//             code.
    	//     }
    	//
    	// All properties except for `generatedLine` and `generatedColumn` can be
    	// `null`.
    	//
    	// `_generatedMappings` is ordered by the generated positions.
    	//
    	// `_originalMappings` is ordered by the original positions.

    	SourceMapConsumer.prototype.__generatedMappings = null;
    	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    	  get: function () {
    	    if (!this.__generatedMappings) {
    	      this._parseMappings(this._mappings, this.sourceRoot);
    	    }

    	    return this.__generatedMappings;
    	  }
    	});

    	SourceMapConsumer.prototype.__originalMappings = null;
    	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    	  get: function () {
    	    if (!this.__originalMappings) {
    	      this._parseMappings(this._mappings, this.sourceRoot);
    	    }

    	    return this.__originalMappings;
    	  }
    	});

    	SourceMapConsumer.prototype._charIsMappingSeparator =
    	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    	    var c = aStr.charAt(index);
    	    return c === ";" || c === ",";
    	  };

    	/**
    	 * Parse the mappings in a string in to a data structure which we can easily
    	 * query (the ordered arrays in the `this.__generatedMappings` and
    	 * `this.__originalMappings` properties).
    	 */
    	SourceMapConsumer.prototype._parseMappings =
    	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    	    throw new Error("Subclasses must implement _parseMappings");
    	  };

    	SourceMapConsumer.GENERATED_ORDER = 1;
    	SourceMapConsumer.ORIGINAL_ORDER = 2;

    	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

    	/**
    	 * Iterate over each mapping between an original source/line/column and a
    	 * generated line/column in this source map.
    	 *
    	 * @param Function aCallback
    	 *        The function that is called with each mapping.
    	 * @param Object aContext
    	 *        Optional. If specified, this object will be the value of `this` every
    	 *        time that `aCallback` is called.
    	 * @param aOrder
    	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
    	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
    	 *        iterate over the mappings sorted by the generated file's line/column
    	 *        order or the original's source/line/column order, respectively. Defaults to
    	 *        `SourceMapConsumer.GENERATED_ORDER`.
    	 */
    	SourceMapConsumer.prototype.eachMapping =
    	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    	    var context = aContext || null;
    	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    	    var mappings;
    	    switch (order) {
    	    case SourceMapConsumer.GENERATED_ORDER:
    	      mappings = this._generatedMappings;
    	      break;
    	    case SourceMapConsumer.ORIGINAL_ORDER:
    	      mappings = this._originalMappings;
    	      break;
    	    default:
    	      throw new Error("Unknown order of iteration.");
    	    }

    	    var sourceRoot = this.sourceRoot;
    	    mappings.map(function (mapping) {
    	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
    	      if (source != null && sourceRoot != null) {
    	        source = util.join(sourceRoot, source);
    	      }
    	      return {
    	        source: source,
    	        generatedLine: mapping.generatedLine,
    	        generatedColumn: mapping.generatedColumn,
    	        originalLine: mapping.originalLine,
    	        originalColumn: mapping.originalColumn,
    	        name: mapping.name === null ? null : this._names.at(mapping.name)
    	      };
    	    }, this).forEach(aCallback, context);
    	  };

    	/**
    	 * Returns all generated line and column information for the original source,
    	 * line, and column provided. If no column is provided, returns all mappings
    	 * corresponding to a either the line we are searching for or the next
    	 * closest line that has any mappings. Otherwise, returns all mappings
    	 * corresponding to the given line and either the column we are searching for
    	 * or the next closest column that has any offsets.
    	 *
    	 * The only argument is an object with the following properties:
    	 *
    	 *   - source: The filename of the original source.
    	 *   - line: The line number in the original source.
    	 *   - column: Optional. the column number in the original source.
    	 *
    	 * and an array of objects is returned, each with the following properties:
    	 *
    	 *   - line: The line number in the generated source, or null.
    	 *   - column: The column number in the generated source, or null.
    	 */
    	SourceMapConsumer.prototype.allGeneratedPositionsFor =
    	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    	    var line = util.getArg(aArgs, 'line');

    	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    	    // returns the index of the closest mapping less than the needle. By
    	    // setting needle.originalColumn to 0, we thus find the last mapping for
    	    // the given line, provided such a mapping exists.
    	    var needle = {
    	      source: util.getArg(aArgs, 'source'),
    	      originalLine: line,
    	      originalColumn: util.getArg(aArgs, 'column', 0)
    	    };

    	    if (this.sourceRoot != null) {
    	      needle.source = util.relative(this.sourceRoot, needle.source);
    	    }
    	    if (!this._sources.has(needle.source)) {
    	      return [];
    	    }
    	    needle.source = this._sources.indexOf(needle.source);

    	    var mappings = [];

    	    var index = this._findMapping(needle,
    	                                  this._originalMappings,
    	                                  "originalLine",
    	                                  "originalColumn",
    	                                  util.compareByOriginalPositions,
    	                                  binarySearch.LEAST_UPPER_BOUND);
    	    if (index >= 0) {
    	      var mapping = this._originalMappings[index];

    	      if (aArgs.column === undefined) {
    	        var originalLine = mapping.originalLine;

    	        // Iterate until either we run out of mappings, or we run into
    	        // a mapping for a different line than the one we found. Since
    	        // mappings are sorted, this is guaranteed to find all mappings for
    	        // the line we found.
    	        while (mapping && mapping.originalLine === originalLine) {
    	          mappings.push({
    	            line: util.getArg(mapping, 'generatedLine', null),
    	            column: util.getArg(mapping, 'generatedColumn', null),
    	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
    	          });

    	          mapping = this._originalMappings[++index];
    	        }
    	      } else {
    	        var originalColumn = mapping.originalColumn;

    	        // Iterate until either we run out of mappings, or we run into
    	        // a mapping for a different line than the one we were searching for.
    	        // Since mappings are sorted, this is guaranteed to find all mappings for
    	        // the line we are searching for.
    	        while (mapping &&
    	               mapping.originalLine === line &&
    	               mapping.originalColumn == originalColumn) {
    	          mappings.push({
    	            line: util.getArg(mapping, 'generatedLine', null),
    	            column: util.getArg(mapping, 'generatedColumn', null),
    	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
    	          });

    	          mapping = this._originalMappings[++index];
    	        }
    	      }
    	    }

    	    return mappings;
    	  };

    	exports.SourceMapConsumer = SourceMapConsumer;

    	/**
    	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
    	 * query for information about the original file positions by giving it a file
    	 * position in the generated source.
    	 *
    	 * The only parameter is the raw source map (either as a JSON string, or
    	 * already parsed to an object). According to the spec, source maps have the
    	 * following attributes:
    	 *
    	 *   - version: Which version of the source map spec this map is following.
    	 *   - sources: An array of URLs to the original source files.
    	 *   - names: An array of identifiers which can be referrenced by individual mappings.
    	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
    	 *   - sourcesContent: Optional. An array of contents of the original source files.
    	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
    	 *   - file: Optional. The generated file this source map is associated with.
    	 *
    	 * Here is an example source map, taken from the source map spec[0]:
    	 *
    	 *     {
    	 *       version : 3,
    	 *       file: "out.js",
    	 *       sourceRoot : "",
    	 *       sources: ["foo.js", "bar.js"],
    	 *       names: ["src", "maps", "are", "fun"],
    	 *       mappings: "AA,AB;;ABCDE;"
    	 *     }
    	 *
    	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
    	 */
    	function BasicSourceMapConsumer(aSourceMap) {
    	  var sourceMap = aSourceMap;
    	  if (typeof aSourceMap === 'string') {
    	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    	  }

    	  var version = util.getArg(sourceMap, 'version');
    	  var sources = util.getArg(sourceMap, 'sources');
    	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    	  // requires the array) to play nice here.
    	  var names = util.getArg(sourceMap, 'names', []);
    	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    	  var mappings = util.getArg(sourceMap, 'mappings');
    	  var file = util.getArg(sourceMap, 'file', null);

    	  // Once again, Sass deviates from the spec and supplies the version as a
    	  // string rather than a number, so we use loose equality checking here.
    	  if (version != this._version) {
    	    throw new Error('Unsupported version: ' + version);
    	  }

    	  sources = sources
    	    .map(String)
    	    // Some source maps produce relative source paths like "./foo.js" instead of
    	    // "foo.js".  Normalize these first so that future comparisons will succeed.
    	    // See bugzil.la/1090768.
    	    .map(util.normalize)
    	    // Always ensure that absolute sources are internally stored relative to
    	    // the source root, if the source root is absolute. Not doing this would
    	    // be particularly problematic when the source root is a prefix of the
    	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    	    .map(function (source) {
    	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
    	        ? util.relative(sourceRoot, source)
    	        : source;
    	    });

    	  // Pass `true` below to allow duplicate names and sources. While source maps
    	  // are intended to be compressed and deduplicated, the TypeScript compiler
    	  // sometimes generates source maps with duplicates in them. See Github issue
    	  // #72 and bugzil.la/889492.
    	  this._names = ArraySet.fromArray(names.map(String), true);
    	  this._sources = ArraySet.fromArray(sources, true);

    	  this.sourceRoot = sourceRoot;
    	  this.sourcesContent = sourcesContent;
    	  this._mappings = mappings;
    	  this.file = file;
    	}

    	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

    	/**
    	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
    	 *
    	 * @param SourceMapGenerator aSourceMap
    	 *        The source map that will be consumed.
    	 * @returns BasicSourceMapConsumer
    	 */
    	BasicSourceMapConsumer.fromSourceMap =
    	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    	    var smc = Object.create(BasicSourceMapConsumer.prototype);

    	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    	    smc.sourceRoot = aSourceMap._sourceRoot;
    	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
    	                                                            smc.sourceRoot);
    	    smc.file = aSourceMap._file;

    	    // Because we are modifying the entries (by converting string sources and
    	    // names to indices into the sources and names ArraySets), we have to make
    	    // a copy of the entry or else bad things happen. Shared mutable state
    	    // strikes again! See github issue #191.

    	    var generatedMappings = aSourceMap._mappings.toArray().slice();
    	    var destGeneratedMappings = smc.__generatedMappings = [];
    	    var destOriginalMappings = smc.__originalMappings = [];

    	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
    	      var srcMapping = generatedMappings[i];
    	      var destMapping = new Mapping;
    	      destMapping.generatedLine = srcMapping.generatedLine;
    	      destMapping.generatedColumn = srcMapping.generatedColumn;

    	      if (srcMapping.source) {
    	        destMapping.source = sources.indexOf(srcMapping.source);
    	        destMapping.originalLine = srcMapping.originalLine;
    	        destMapping.originalColumn = srcMapping.originalColumn;

    	        if (srcMapping.name) {
    	          destMapping.name = names.indexOf(srcMapping.name);
    	        }

    	        destOriginalMappings.push(destMapping);
    	      }

    	      destGeneratedMappings.push(destMapping);
    	    }

    	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    	    return smc;
    	  };

    	/**
    	 * The version of the source mapping spec that we are consuming.
    	 */
    	BasicSourceMapConsumer.prototype._version = 3;

    	/**
    	 * The list of original sources.
    	 */
    	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    	  get: function () {
    	    return this._sources.toArray().map(function (s) {
    	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    	    }, this);
    	  }
    	});

    	/**
    	 * Provide the JIT with a nice shape / hidden class.
    	 */
    	function Mapping() {
    	  this.generatedLine = 0;
    	  this.generatedColumn = 0;
    	  this.source = null;
    	  this.originalLine = null;
    	  this.originalColumn = null;
    	  this.name = null;
    	}

    	/**
    	 * Parse the mappings in a string in to a data structure which we can easily
    	 * query (the ordered arrays in the `this.__generatedMappings` and
    	 * `this.__originalMappings` properties).
    	 */
    	BasicSourceMapConsumer.prototype._parseMappings =
    	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    	    var generatedLine = 1;
    	    var previousGeneratedColumn = 0;
    	    var previousOriginalLine = 0;
    	    var previousOriginalColumn = 0;
    	    var previousSource = 0;
    	    var previousName = 0;
    	    var length = aStr.length;
    	    var index = 0;
    	    var cachedSegments = {};
    	    var temp = {};
    	    var originalMappings = [];
    	    var generatedMappings = [];
    	    var mapping, str, segment, end, value;

    	    while (index < length) {
    	      if (aStr.charAt(index) === ';') {
    	        generatedLine++;
    	        index++;
    	        previousGeneratedColumn = 0;
    	      }
    	      else if (aStr.charAt(index) === ',') {
    	        index++;
    	      }
    	      else {
    	        mapping = new Mapping();
    	        mapping.generatedLine = generatedLine;

    	        // Because each offset is encoded relative to the previous one,
    	        // many segments often have the same encoding. We can exploit this
    	        // fact by caching the parsed variable length fields of each segment,
    	        // allowing us to avoid a second parse if we encounter the same
    	        // segment again.
    	        for (end = index; end < length; end++) {
    	          if (this._charIsMappingSeparator(aStr, end)) {
    	            break;
    	          }
    	        }
    	        str = aStr.slice(index, end);

    	        segment = cachedSegments[str];
    	        if (segment) {
    	          index += str.length;
    	        } else {
    	          segment = [];
    	          while (index < end) {
    	            base64VLQ.decode(aStr, index, temp);
    	            value = temp.value;
    	            index = temp.rest;
    	            segment.push(value);
    	          }

    	          if (segment.length === 2) {
    	            throw new Error('Found a source, but no line and column');
    	          }

    	          if (segment.length === 3) {
    	            throw new Error('Found a source and line, but no column');
    	          }

    	          cachedSegments[str] = segment;
    	        }

    	        // Generated column.
    	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
    	        previousGeneratedColumn = mapping.generatedColumn;

    	        if (segment.length > 1) {
    	          // Original source.
    	          mapping.source = previousSource + segment[1];
    	          previousSource += segment[1];

    	          // Original line.
    	          mapping.originalLine = previousOriginalLine + segment[2];
    	          previousOriginalLine = mapping.originalLine;
    	          // Lines are stored 0-based
    	          mapping.originalLine += 1;

    	          // Original column.
    	          mapping.originalColumn = previousOriginalColumn + segment[3];
    	          previousOriginalColumn = mapping.originalColumn;

    	          if (segment.length > 4) {
    	            // Original name.
    	            mapping.name = previousName + segment[4];
    	            previousName += segment[4];
    	          }
    	        }

    	        generatedMappings.push(mapping);
    	        if (typeof mapping.originalLine === 'number') {
    	          originalMappings.push(mapping);
    	        }
    	      }
    	    }

    	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    	    this.__generatedMappings = generatedMappings;

    	    quickSort(originalMappings, util.compareByOriginalPositions);
    	    this.__originalMappings = originalMappings;
    	  };

    	/**
    	 * Find the mapping that best matches the hypothetical "needle" mapping that
    	 * we are searching for in the given "haystack" of mappings.
    	 */
    	BasicSourceMapConsumer.prototype._findMapping =
    	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
    	                                         aColumnName, aComparator, aBias) {
    	    // To return the position we are searching for, we must first find the
    	    // mapping for the given position and then return the opposite position it
    	    // points to. Because the mappings are sorted, we can use binary search to
    	    // find the best mapping.

    	    if (aNeedle[aLineName] <= 0) {
    	      throw new TypeError('Line must be greater than or equal to 1, got '
    	                          + aNeedle[aLineName]);
    	    }
    	    if (aNeedle[aColumnName] < 0) {
    	      throw new TypeError('Column must be greater than or equal to 0, got '
    	                          + aNeedle[aColumnName]);
    	    }

    	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    	  };

    	/**
    	 * Compute the last column for each generated mapping. The last column is
    	 * inclusive.
    	 */
    	BasicSourceMapConsumer.prototype.computeColumnSpans =
    	  function SourceMapConsumer_computeColumnSpans() {
    	    for (var index = 0; index < this._generatedMappings.length; ++index) {
    	      var mapping = this._generatedMappings[index];

    	      // Mappings do not contain a field for the last generated columnt. We
    	      // can come up with an optimistic estimate, however, by assuming that
    	      // mappings are contiguous (i.e. given two consecutive mappings, the
    	      // first mapping ends where the second one starts).
    	      if (index + 1 < this._generatedMappings.length) {
    	        var nextMapping = this._generatedMappings[index + 1];

    	        if (mapping.generatedLine === nextMapping.generatedLine) {
    	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
    	          continue;
    	        }
    	      }

    	      // The last mapping for each line spans the entire line.
    	      mapping.lastGeneratedColumn = Infinity;
    	    }
    	  };

    	/**
    	 * Returns the original source, line, and column information for the generated
    	 * source's line and column positions provided. The only argument is an object
    	 * with the following properties:
    	 *
    	 *   - line: The line number in the generated source.
    	 *   - column: The column number in the generated source.
    	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
    	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
    	 *     closest element that is smaller than or greater than the one we are
    	 *     searching for, respectively, if the exact element cannot be found.
    	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
    	 *
    	 * and an object is returned with the following properties:
    	 *
    	 *   - source: The original source file, or null.
    	 *   - line: The line number in the original source, or null.
    	 *   - column: The column number in the original source, or null.
    	 *   - name: The original identifier, or null.
    	 */
    	BasicSourceMapConsumer.prototype.originalPositionFor =
    	  function SourceMapConsumer_originalPositionFor(aArgs) {
    	    var needle = {
    	      generatedLine: util.getArg(aArgs, 'line'),
    	      generatedColumn: util.getArg(aArgs, 'column')
    	    };

    	    var index = this._findMapping(
    	      needle,
    	      this._generatedMappings,
    	      "generatedLine",
    	      "generatedColumn",
    	      util.compareByGeneratedPositionsDeflated,
    	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    	    );

    	    if (index >= 0) {
    	      var mapping = this._generatedMappings[index];

    	      if (mapping.generatedLine === needle.generatedLine) {
    	        var source = util.getArg(mapping, 'source', null);
    	        if (source !== null) {
    	          source = this._sources.at(source);
    	          if (this.sourceRoot != null) {
    	            source = util.join(this.sourceRoot, source);
    	          }
    	        }
    	        var name = util.getArg(mapping, 'name', null);
    	        if (name !== null) {
    	          name = this._names.at(name);
    	        }
    	        return {
    	          source: source,
    	          line: util.getArg(mapping, 'originalLine', null),
    	          column: util.getArg(mapping, 'originalColumn', null),
    	          name: name
    	        };
    	      }
    	    }

    	    return {
    	      source: null,
    	      line: null,
    	      column: null,
    	      name: null
    	    };
    	  };

    	/**
    	 * Return true if we have the source content for every source in the source
    	 * map, false otherwise.
    	 */
    	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    	    if (!this.sourcesContent) {
    	      return false;
    	    }
    	    return this.sourcesContent.length >= this._sources.size() &&
    	      !this.sourcesContent.some(function (sc) { return sc == null; });
    	  };

    	/**
    	 * Returns the original source content. The only argument is the url of the
    	 * original source file. Returns null if no original source content is
    	 * available.
    	 */
    	BasicSourceMapConsumer.prototype.sourceContentFor =
    	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    	    if (!this.sourcesContent) {
    	      return null;
    	    }

    	    if (this.sourceRoot != null) {
    	      aSource = util.relative(this.sourceRoot, aSource);
    	    }

    	    if (this._sources.has(aSource)) {
    	      return this.sourcesContent[this._sources.indexOf(aSource)];
    	    }

    	    var url;
    	    if (this.sourceRoot != null
    	        && (url = util.urlParse(this.sourceRoot))) {
    	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    	      // many users. We can help them out when they expect file:// URIs to
    	      // behave like it would if they were running a local HTTP server. See
    	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
    	      if (url.scheme == "file"
    	          && this._sources.has(fileUriAbsPath)) {
    	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
    	      }

    	      if ((!url.path || url.path == "/")
    	          && this._sources.has("/" + aSource)) {
    	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
    	      }
    	    }

    	    // This function is used recursively from
    	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    	    // don't want to throw if we can't find the source - we just want to
    	    // return null, so we provide a flag to exit gracefully.
    	    if (nullOnMissing) {
    	      return null;
    	    }
    	    else {
    	      throw new Error('"' + aSource + '" is not in the SourceMap.');
    	    }
    	  };

    	/**
    	 * Returns the generated line and column information for the original source,
    	 * line, and column positions provided. The only argument is an object with
    	 * the following properties:
    	 *
    	 *   - source: The filename of the original source.
    	 *   - line: The line number in the original source.
    	 *   - column: The column number in the original source.
    	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
    	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
    	 *     closest element that is smaller than or greater than the one we are
    	 *     searching for, respectively, if the exact element cannot be found.
    	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
    	 *
    	 * and an object is returned with the following properties:
    	 *
    	 *   - line: The line number in the generated source, or null.
    	 *   - column: The column number in the generated source, or null.
    	 */
    	BasicSourceMapConsumer.prototype.generatedPositionFor =
    	  function SourceMapConsumer_generatedPositionFor(aArgs) {
    	    var source = util.getArg(aArgs, 'source');
    	    if (this.sourceRoot != null) {
    	      source = util.relative(this.sourceRoot, source);
    	    }
    	    if (!this._sources.has(source)) {
    	      return {
    	        line: null,
    	        column: null,
    	        lastColumn: null
    	      };
    	    }
    	    source = this._sources.indexOf(source);

    	    var needle = {
    	      source: source,
    	      originalLine: util.getArg(aArgs, 'line'),
    	      originalColumn: util.getArg(aArgs, 'column')
    	    };

    	    var index = this._findMapping(
    	      needle,
    	      this._originalMappings,
    	      "originalLine",
    	      "originalColumn",
    	      util.compareByOriginalPositions,
    	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    	    );

    	    if (index >= 0) {
    	      var mapping = this._originalMappings[index];

    	      if (mapping.source === needle.source) {
    	        return {
    	          line: util.getArg(mapping, 'generatedLine', null),
    	          column: util.getArg(mapping, 'generatedColumn', null),
    	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
    	        };
    	      }
    	    }

    	    return {
    	      line: null,
    	      column: null,
    	      lastColumn: null
    	    };
    	  };

    	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

    	/**
    	 * An IndexedSourceMapConsumer instance represents a parsed source map which
    	 * we can query for information. It differs from BasicSourceMapConsumer in
    	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
    	 * input.
    	 *
    	 * The only parameter is a raw source map (either as a JSON string, or already
    	 * parsed to an object). According to the spec for indexed source maps, they
    	 * have the following attributes:
    	 *
    	 *   - version: Which version of the source map spec this map is following.
    	 *   - file: Optional. The generated file this source map is associated with.
    	 *   - sections: A list of section definitions.
    	 *
    	 * Each value under the "sections" field has two fields:
    	 *   - offset: The offset into the original specified at which this section
    	 *       begins to apply, defined as an object with a "line" and "column"
    	 *       field.
    	 *   - map: A source map definition. This source map could also be indexed,
    	 *       but doesn't have to be.
    	 *
    	 * Instead of the "map" field, it's also possible to have a "url" field
    	 * specifying a URL to retrieve a source map from, but that's currently
    	 * unsupported.
    	 *
    	 * Here's an example source map, taken from the source map spec[0], but
    	 * modified to omit a section which uses the "url" field.
    	 *
    	 *  {
    	 *    version : 3,
    	 *    file: "app.js",
    	 *    sections: [{
    	 *      offset: {line:100, column:10},
    	 *      map: {
    	 *        version : 3,
    	 *        file: "section.js",
    	 *        sources: ["foo.js", "bar.js"],
    	 *        names: ["src", "maps", "are", "fun"],
    	 *        mappings: "AAAA,E;;ABCDE;"
    	 *      }
    	 *    }],
    	 *  }
    	 *
    	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
    	 */
    	function IndexedSourceMapConsumer(aSourceMap) {
    	  var sourceMap = aSourceMap;
    	  if (typeof aSourceMap === 'string') {
    	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    	  }

    	  var version = util.getArg(sourceMap, 'version');
    	  var sections = util.getArg(sourceMap, 'sections');

    	  if (version != this._version) {
    	    throw new Error('Unsupported version: ' + version);
    	  }

    	  this._sources = new ArraySet();
    	  this._names = new ArraySet();

    	  var lastOffset = {
    	    line: -1,
    	    column: 0
    	  };
    	  this._sections = sections.map(function (s) {
    	    if (s.url) {
    	      // The url field will require support for asynchronicity.
    	      // See https://github.com/mozilla/source-map/issues/16
    	      throw new Error('Support for url field in sections not implemented.');
    	    }
    	    var offset = util.getArg(s, 'offset');
    	    var offsetLine = util.getArg(offset, 'line');
    	    var offsetColumn = util.getArg(offset, 'column');

    	    if (offsetLine < lastOffset.line ||
    	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
    	      throw new Error('Section offsets must be ordered and non-overlapping.');
    	    }
    	    lastOffset = offset;

    	    return {
    	      generatedOffset: {
    	        // The offset fields are 0-based, but we use 1-based indices when
    	        // encoding/decoding from VLQ.
    	        generatedLine: offsetLine + 1,
    	        generatedColumn: offsetColumn + 1
    	      },
    	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    	    }
    	  });
    	}

    	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

    	/**
    	 * The version of the source mapping spec that we are consuming.
    	 */
    	IndexedSourceMapConsumer.prototype._version = 3;

    	/**
    	 * The list of original sources.
    	 */
    	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    	  get: function () {
    	    var sources = [];
    	    for (var i = 0; i < this._sections.length; i++) {
    	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
    	        sources.push(this._sections[i].consumer.sources[j]);
    	      }
    	    }
    	    return sources;
    	  }
    	});

    	/**
    	 * Returns the original source, line, and column information for the generated
    	 * source's line and column positions provided. The only argument is an object
    	 * with the following properties:
    	 *
    	 *   - line: The line number in the generated source.
    	 *   - column: The column number in the generated source.
    	 *
    	 * and an object is returned with the following properties:
    	 *
    	 *   - source: The original source file, or null.
    	 *   - line: The line number in the original source, or null.
    	 *   - column: The column number in the original source, or null.
    	 *   - name: The original identifier, or null.
    	 */
    	IndexedSourceMapConsumer.prototype.originalPositionFor =
    	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    	    var needle = {
    	      generatedLine: util.getArg(aArgs, 'line'),
    	      generatedColumn: util.getArg(aArgs, 'column')
    	    };

    	    // Find the section containing the generated position we're trying to map
    	    // to an original position.
    	    var sectionIndex = binarySearch.search(needle, this._sections,
    	      function(needle, section) {
    	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    	        if (cmp) {
    	          return cmp;
    	        }

    	        return (needle.generatedColumn -
    	                section.generatedOffset.generatedColumn);
    	      });
    	    var section = this._sections[sectionIndex];

    	    if (!section) {
    	      return {
    	        source: null,
    	        line: null,
    	        column: null,
    	        name: null
    	      };
    	    }

    	    return section.consumer.originalPositionFor({
    	      line: needle.generatedLine -
    	        (section.generatedOffset.generatedLine - 1),
    	      column: needle.generatedColumn -
    	        (section.generatedOffset.generatedLine === needle.generatedLine
    	         ? section.generatedOffset.generatedColumn - 1
    	         : 0),
    	      bias: aArgs.bias
    	    });
    	  };

    	/**
    	 * Return true if we have the source content for every source in the source
    	 * map, false otherwise.
    	 */
    	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    	    return this._sections.every(function (s) {
    	      return s.consumer.hasContentsOfAllSources();
    	    });
    	  };

    	/**
    	 * Returns the original source content. The only argument is the url of the
    	 * original source file. Returns null if no original source content is
    	 * available.
    	 */
    	IndexedSourceMapConsumer.prototype.sourceContentFor =
    	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    	    for (var i = 0; i < this._sections.length; i++) {
    	      var section = this._sections[i];

    	      var content = section.consumer.sourceContentFor(aSource, true);
    	      if (content) {
    	        return content;
    	      }
    	    }
    	    if (nullOnMissing) {
    	      return null;
    	    }
    	    else {
    	      throw new Error('"' + aSource + '" is not in the SourceMap.');
    	    }
    	  };

    	/**
    	 * Returns the generated line and column information for the original source,
    	 * line, and column positions provided. The only argument is an object with
    	 * the following properties:
    	 *
    	 *   - source: The filename of the original source.
    	 *   - line: The line number in the original source.
    	 *   - column: The column number in the original source.
    	 *
    	 * and an object is returned with the following properties:
    	 *
    	 *   - line: The line number in the generated source, or null.
    	 *   - column: The column number in the generated source, or null.
    	 */
    	IndexedSourceMapConsumer.prototype.generatedPositionFor =
    	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    	    for (var i = 0; i < this._sections.length; i++) {
    	      var section = this._sections[i];

    	      // Only consider this section if the requested source is in the list of
    	      // sources of the consumer.
    	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
    	        continue;
    	      }
    	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    	      if (generatedPosition) {
    	        var ret = {
    	          line: generatedPosition.line +
    	            (section.generatedOffset.generatedLine - 1),
    	          column: generatedPosition.column +
    	            (section.generatedOffset.generatedLine === generatedPosition.line
    	             ? section.generatedOffset.generatedColumn - 1
    	             : 0)
    	        };
    	        return ret;
    	      }
    	    }

    	    return {
    	      line: null,
    	      column: null
    	    };
    	  };

    	/**
    	 * Parse the mappings in a string in to a data structure which we can easily
    	 * query (the ordered arrays in the `this.__generatedMappings` and
    	 * `this.__originalMappings` properties).
    	 */
    	IndexedSourceMapConsumer.prototype._parseMappings =
    	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    	    this.__generatedMappings = [];
    	    this.__originalMappings = [];
    	    for (var i = 0; i < this._sections.length; i++) {
    	      var section = this._sections[i];
    	      var sectionMappings = section.consumer._generatedMappings;
    	      for (var j = 0; j < sectionMappings.length; j++) {
    	        var mapping = sectionMappings[j];

    	        var source = section.consumer._sources.at(mapping.source);
    	        if (section.consumer.sourceRoot !== null) {
    	          source = util.join(section.consumer.sourceRoot, source);
    	        }
    	        this._sources.add(source);
    	        source = this._sources.indexOf(source);

    	        var name = section.consumer._names.at(mapping.name);
    	        this._names.add(name);
    	        name = this._names.indexOf(name);

    	        // The mappings coming from the consumer for the section have
    	        // generated positions relative to the start of the section, so we
    	        // need to offset them to be relative to the start of the concatenated
    	        // generated file.
    	        var adjustedMapping = {
    	          source: source,
    	          generatedLine: mapping.generatedLine +
    	            (section.generatedOffset.generatedLine - 1),
    	          generatedColumn: mapping.generatedColumn +
    	            (section.generatedOffset.generatedLine === mapping.generatedLine
    	            ? section.generatedOffset.generatedColumn - 1
    	            : 0),
    	          originalLine: mapping.originalLine,
    	          originalColumn: mapping.originalColumn,
    	          name: name
    	        };

    	        this.__generatedMappings.push(adjustedMapping);
    	        if (typeof adjustedMapping.originalLine === 'number') {
    	          this.__originalMappings.push(adjustedMapping);
    	        }
    	      }
    	    }

    	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
    	  };

    	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


    /***/ }),
    /* 2 */
    /***/ (function(module, exports) {

    	/* -*- Mode: js; js-indent-level: 2; -*- */
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	/**
    	 * This is a helper function for getting values from parameter/options
    	 * objects.
    	 *
    	 * @param args The object we are extracting values from
    	 * @param name The name of the property we are getting.
    	 * @param defaultValue An optional value to return if the property is missing
    	 * from the object. If this is not specified and the property is missing, an
    	 * error will be thrown.
    	 */
    	function getArg(aArgs, aName, aDefaultValue) {
    	  if (aName in aArgs) {
    	    return aArgs[aName];
    	  } else if (arguments.length === 3) {
    	    return aDefaultValue;
    	  } else {
    	    throw new Error('"' + aName + '" is a required argument.');
    	  }
    	}
    	exports.getArg = getArg;

    	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    	var dataUrlRegexp = /^data:.+\,.+$/;

    	function urlParse(aUrl) {
    	  var match = aUrl.match(urlRegexp);
    	  if (!match) {
    	    return null;
    	  }
    	  return {
    	    scheme: match[1],
    	    auth: match[2],
    	    host: match[3],
    	    port: match[4],
    	    path: match[5]
    	  };
    	}
    	exports.urlParse = urlParse;

    	function urlGenerate(aParsedUrl) {
    	  var url = '';
    	  if (aParsedUrl.scheme) {
    	    url += aParsedUrl.scheme + ':';
    	  }
    	  url += '//';
    	  if (aParsedUrl.auth) {
    	    url += aParsedUrl.auth + '@';
    	  }
    	  if (aParsedUrl.host) {
    	    url += aParsedUrl.host;
    	  }
    	  if (aParsedUrl.port) {
    	    url += ":" + aParsedUrl.port;
    	  }
    	  if (aParsedUrl.path) {
    	    url += aParsedUrl.path;
    	  }
    	  return url;
    	}
    	exports.urlGenerate = urlGenerate;

    	/**
    	 * Normalizes a path, or the path portion of a URL:
    	 *
    	 * - Replaces consecutive slashes with one slash.
    	 * - Removes unnecessary '.' parts.
    	 * - Removes unnecessary '<dir>/..' parts.
    	 *
    	 * Based on code in the Node.js 'path' core module.
    	 *
    	 * @param aPath The path or url to normalize.
    	 */
    	function normalize(aPath) {
    	  var path = aPath;
    	  var url = urlParse(aPath);
    	  if (url) {
    	    if (!url.path) {
    	      return aPath;
    	    }
    	    path = url.path;
    	  }
    	  var isAbsolute = exports.isAbsolute(path);

    	  var parts = path.split(/\/+/);
    	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    	    part = parts[i];
    	    if (part === '.') {
    	      parts.splice(i, 1);
    	    } else if (part === '..') {
    	      up++;
    	    } else if (up > 0) {
    	      if (part === '') {
    	        // The first part is blank if the path is absolute. Trying to go
    	        // above the root is a no-op. Therefore we can remove all '..' parts
    	        // directly after the root.
    	        parts.splice(i + 1, up);
    	        up = 0;
    	      } else {
    	        parts.splice(i, 2);
    	        up--;
    	      }
    	    }
    	  }
    	  path = parts.join('/');

    	  if (path === '') {
    	    path = isAbsolute ? '/' : '.';
    	  }

    	  if (url) {
    	    url.path = path;
    	    return urlGenerate(url);
    	  }
    	  return path;
    	}
    	exports.normalize = normalize;

    	/**
    	 * Joins two paths/URLs.
    	 *
    	 * @param aRoot The root path or URL.
    	 * @param aPath The path or URL to be joined with the root.
    	 *
    	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
    	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
    	 *   first.
    	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
    	 *   is updated with the result and aRoot is returned. Otherwise the result
    	 *   is returned.
    	 *   - If aPath is absolute, the result is aPath.
    	 *   - Otherwise the two paths are joined with a slash.
    	 * - Joining for example 'http://' and 'www.example.com' is also supported.
    	 */
    	function join(aRoot, aPath) {
    	  if (aRoot === "") {
    	    aRoot = ".";
    	  }
    	  if (aPath === "") {
    	    aPath = ".";
    	  }
    	  var aPathUrl = urlParse(aPath);
    	  var aRootUrl = urlParse(aRoot);
    	  if (aRootUrl) {
    	    aRoot = aRootUrl.path || '/';
    	  }

    	  // `join(foo, '//www.example.org')`
    	  if (aPathUrl && !aPathUrl.scheme) {
    	    if (aRootUrl) {
    	      aPathUrl.scheme = aRootUrl.scheme;
    	    }
    	    return urlGenerate(aPathUrl);
    	  }

    	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    	    return aPath;
    	  }

    	  // `join('http://', 'www.example.com')`
    	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    	    aRootUrl.host = aPath;
    	    return urlGenerate(aRootUrl);
    	  }

    	  var joined = aPath.charAt(0) === '/'
    	    ? aPath
    	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    	  if (aRootUrl) {
    	    aRootUrl.path = joined;
    	    return urlGenerate(aRootUrl);
    	  }
    	  return joined;
    	}
    	exports.join = join;

    	exports.isAbsolute = function (aPath) {
    	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
    	};

    	/**
    	 * Make a path relative to a URL or another path.
    	 *
    	 * @param aRoot The root path or URL.
    	 * @param aPath The path or URL to be made relative to aRoot.
    	 */
    	function relative(aRoot, aPath) {
    	  if (aRoot === "") {
    	    aRoot = ".";
    	  }

    	  aRoot = aRoot.replace(/\/$/, '');

    	  // It is possible for the path to be above the root. In this case, simply
    	  // checking whether the root is a prefix of the path won't work. Instead, we
    	  // need to remove components from the root one by one, until either we find
    	  // a prefix that fits, or we run out of components to remove.
    	  var level = 0;
    	  while (aPath.indexOf(aRoot + '/') !== 0) {
    	    var index = aRoot.lastIndexOf("/");
    	    if (index < 0) {
    	      return aPath;
    	    }

    	    // If the only part of the root that is left is the scheme (i.e. http://,
    	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    	    // have exhausted all components, so the path is not relative to the root.
    	    aRoot = aRoot.slice(0, index);
    	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
    	      return aPath;
    	    }

    	    ++level;
    	  }

    	  // Make sure we add a "../" for each component we removed from the root.
    	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    	}
    	exports.relative = relative;

    	var supportsNullProto = (function () {
    	  var obj = Object.create(null);
    	  return !('__proto__' in obj);
    	}());

    	function identity (s) {
    	  return s;
    	}

    	/**
    	 * Because behavior goes wacky when you set `__proto__` on objects, we
    	 * have to prefix all the strings in our set with an arbitrary character.
    	 *
    	 * See https://github.com/mozilla/source-map/pull/31 and
    	 * https://github.com/mozilla/source-map/issues/30
    	 *
    	 * @param String aStr
    	 */
    	function toSetString(aStr) {
    	  if (isProtoString(aStr)) {
    	    return '$' + aStr;
    	  }

    	  return aStr;
    	}
    	exports.toSetString = supportsNullProto ? identity : toSetString;

    	function fromSetString(aStr) {
    	  if (isProtoString(aStr)) {
    	    return aStr.slice(1);
    	  }

    	  return aStr;
    	}
    	exports.fromSetString = supportsNullProto ? identity : fromSetString;

    	function isProtoString(s) {
    	  if (!s) {
    	    return false;
    	  }

    	  var length = s.length;

    	  if (length < 9 /* "__proto__".length */) {
    	    return false;
    	  }

    	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
    	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
    	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
    	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
    	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
    	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
    	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
    	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
    	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    	    return false;
    	  }

    	  for (var i = length - 10; i >= 0; i--) {
    	    if (s.charCodeAt(i) !== 36 /* '$' */) {
    	      return false;
    	    }
    	  }

    	  return true;
    	}

    	/**
    	 * Comparator between two mappings where the original positions are compared.
    	 *
    	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
    	 * mappings with the same original source/line/column, but different generated
    	 * line and column the same. Useful when searching for a mapping with a
    	 * stubbed out mapping.
    	 */
    	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    	  var cmp = mappingA.source - mappingB.source;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.originalLine - mappingB.originalLine;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.originalColumn - mappingB.originalColumn;
    	  if (cmp !== 0 || onlyCompareOriginal) {
    	    return cmp;
    	  }

    	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.generatedLine - mappingB.generatedLine;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  return mappingA.name - mappingB.name;
    	}
    	exports.compareByOriginalPositions = compareByOriginalPositions;

    	/**
    	 * Comparator between two mappings with deflated source and name indices where
    	 * the generated positions are compared.
    	 *
    	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
    	 * mappings with the same generated line and column, but different
    	 * source/name/original line and column the same. Useful when searching for a
    	 * mapping with a stubbed out mapping.
    	 */
    	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    	  if (cmp !== 0 || onlyCompareGenerated) {
    	    return cmp;
    	  }

    	  cmp = mappingA.source - mappingB.source;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.originalLine - mappingB.originalLine;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.originalColumn - mappingB.originalColumn;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  return mappingA.name - mappingB.name;
    	}
    	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

    	function strcmp(aStr1, aStr2) {
    	  if (aStr1 === aStr2) {
    	    return 0;
    	  }

    	  if (aStr1 > aStr2) {
    	    return 1;
    	  }

    	  return -1;
    	}

    	/**
    	 * Comparator between two mappings with inflated source and name strings where
    	 * the generated positions are compared.
    	 */
    	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = strcmp(mappingA.source, mappingB.source);
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.originalLine - mappingB.originalLine;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  cmp = mappingA.originalColumn - mappingB.originalColumn;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  return strcmp(mappingA.name, mappingB.name);
    	}
    	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


    /***/ }),
    /* 3 */
    /***/ (function(module, exports) {

    	/* -*- Mode: js; js-indent-level: 2; -*- */
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	exports.GREATEST_LOWER_BOUND = 1;
    	exports.LEAST_UPPER_BOUND = 2;

    	/**
    	 * Recursive implementation of binary search.
    	 *
    	 * @param aLow Indices here and lower do not contain the needle.
    	 * @param aHigh Indices here and higher do not contain the needle.
    	 * @param aNeedle The element being searched for.
    	 * @param aHaystack The non-empty array being searched.
    	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
    	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
    	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
    	 *     closest element that is smaller than or greater than the one we are
    	 *     searching for, respectively, if the exact element cannot be found.
    	 */
    	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    	  // This function terminates when one of the following is true:
    	  //
    	  //   1. We find the exact element we are looking for.
    	  //
    	  //   2. We did not find the exact element, but we can return the index of
    	  //      the next-closest element.
    	  //
    	  //   3. We did not find the exact element, and there is no next-closest
    	  //      element than the one we are searching for, so we return -1.
    	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
    	  if (cmp === 0) {
    	    // Found the element we are looking for.
    	    return mid;
    	  }
    	  else if (cmp > 0) {
    	    // Our needle is greater than aHaystack[mid].
    	    if (aHigh - mid > 1) {
    	      // The element is in the upper half.
    	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    	    }

    	    // The exact needle element was not found in this haystack. Determine if
    	    // we are in termination case (3) or (2) and return the appropriate thing.
    	    if (aBias == exports.LEAST_UPPER_BOUND) {
    	      return aHigh < aHaystack.length ? aHigh : -1;
    	    } else {
    	      return mid;
    	    }
    	  }
    	  else {
    	    // Our needle is less than aHaystack[mid].
    	    if (mid - aLow > 1) {
    	      // The element is in the lower half.
    	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    	    }

    	    // we are in termination case (3) or (2) and return the appropriate thing.
    	    if (aBias == exports.LEAST_UPPER_BOUND) {
    	      return mid;
    	    } else {
    	      return aLow < 0 ? -1 : aLow;
    	    }
    	  }
    	}

    	/**
    	 * This is an implementation of binary search which will always try and return
    	 * the index of the closest element if there is no exact hit. This is because
    	 * mappings between original and generated line/col pairs are single points,
    	 * and there is an implicit region between each of them, so a miss just means
    	 * that you aren't on the very start of a region.
    	 *
    	 * @param aNeedle The element you are looking for.
    	 * @param aHaystack The array that is being searched.
    	 * @param aCompare A function which takes the needle and an element in the
    	 *     array and returns -1, 0, or 1 depending on whether the needle is less
    	 *     than, equal to, or greater than the element, respectively.
    	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
    	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
    	 *     closest element that is smaller than or greater than the one we are
    	 *     searching for, respectively, if the exact element cannot be found.
    	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
    	 */
    	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    	  if (aHaystack.length === 0) {
    	    return -1;
    	  }

    	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
    	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    	  if (index < 0) {
    	    return -1;
    	  }

    	  // We have found either the exact element, or the next-closest element than
    	  // the one we are searching for. However, there may be more than one such
    	  // element. Make sure we always return the smallest of these.
    	  while (index - 1 >= 0) {
    	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
    	      break;
    	    }
    	    --index;
    	  }

    	  return index;
    	};


    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {

    	/* -*- Mode: js; js-indent-level: 2; -*- */
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	var util = __webpack_require__(2);
    	var has = Object.prototype.hasOwnProperty;

    	/**
    	 * A data structure which is a combination of an array and a set. Adding a new
    	 * member is O(1), testing for membership is O(1), and finding the index of an
    	 * element is O(1). Removing elements from the set is not supported. Only
    	 * strings are supported for membership.
    	 */
    	function ArraySet() {
    	  this._array = [];
    	  this._set = Object.create(null);
    	}

    	/**
    	 * Static method for creating ArraySet instances from an existing array.
    	 */
    	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    	  var set = new ArraySet();
    	  for (var i = 0, len = aArray.length; i < len; i++) {
    	    set.add(aArray[i], aAllowDuplicates);
    	  }
    	  return set;
    	};

    	/**
    	 * Return how many unique items are in this ArraySet. If duplicates have been
    	 * added, than those do not count towards the size.
    	 *
    	 * @returns Number
    	 */
    	ArraySet.prototype.size = function ArraySet_size() {
    	  return Object.getOwnPropertyNames(this._set).length;
    	};

    	/**
    	 * Add the given string to this set.
    	 *
    	 * @param String aStr
    	 */
    	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    	  var sStr = util.toSetString(aStr);
    	  var isDuplicate = has.call(this._set, sStr);
    	  var idx = this._array.length;
    	  if (!isDuplicate || aAllowDuplicates) {
    	    this._array.push(aStr);
    	  }
    	  if (!isDuplicate) {
    	    this._set[sStr] = idx;
    	  }
    	};

    	/**
    	 * Is the given string a member of this set?
    	 *
    	 * @param String aStr
    	 */
    	ArraySet.prototype.has = function ArraySet_has(aStr) {
    	  var sStr = util.toSetString(aStr);
    	  return has.call(this._set, sStr);
    	};

    	/**
    	 * What is the index of the given string in the array?
    	 *
    	 * @param String aStr
    	 */
    	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    	  var sStr = util.toSetString(aStr);
    	  if (has.call(this._set, sStr)) {
    	    return this._set[sStr];
    	  }
    	  throw new Error('"' + aStr + '" is not in the set.');
    	};

    	/**
    	 * What is the element at the given index?
    	 *
    	 * @param Number aIdx
    	 */
    	ArraySet.prototype.at = function ArraySet_at(aIdx) {
    	  if (aIdx >= 0 && aIdx < this._array.length) {
    	    return this._array[aIdx];
    	  }
    	  throw new Error('No element indexed by ' + aIdx);
    	};

    	/**
    	 * Returns the array representation of this set (which has the proper indices
    	 * indicated by indexOf). Note that this is a copy of the internal array used
    	 * for storing the members so that no one can mess with internal state.
    	 */
    	ArraySet.prototype.toArray = function ArraySet_toArray() {
    	  return this._array.slice();
    	};

    	exports.ArraySet = ArraySet;


    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {

    	/* -*- Mode: js; js-indent-level: 2; -*- */
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 *
    	 * Based on the Base 64 VLQ implementation in Closure Compiler:
    	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
    	 *
    	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
    	 * Redistribution and use in source and binary forms, with or without
    	 * modification, are permitted provided that the following conditions are
    	 * met:
    	 *
    	 *  * Redistributions of source code must retain the above copyright
    	 *    notice, this list of conditions and the following disclaimer.
    	 *  * Redistributions in binary form must reproduce the above
    	 *    copyright notice, this list of conditions and the following
    	 *    disclaimer in the documentation and/or other materials provided
    	 *    with the distribution.
    	 *  * Neither the name of Google Inc. nor the names of its
    	 *    contributors may be used to endorse or promote products derived
    	 *    from this software without specific prior written permission.
    	 *
    	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    	 */

    	var base64 = __webpack_require__(6);

    	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
    	// length quantities we use in the source map spec, the first bit is the sign,
    	// the next four bits are the actual value, and the 6th bit is the
    	// continuation bit. The continuation bit tells us whether there are more
    	// digits in this value following this digit.
    	//
    	//   Continuation
    	//   |    Sign
    	//   |    |
    	//   V    V
    	//   101011

    	var VLQ_BASE_SHIFT = 5;

    	// binary: 100000
    	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

    	// binary: 011111
    	var VLQ_BASE_MASK = VLQ_BASE - 1;

    	// binary: 100000
    	var VLQ_CONTINUATION_BIT = VLQ_BASE;

    	/**
    	 * Converts from a two-complement value to a value where the sign bit is
    	 * placed in the least significant bit.  For example, as decimals:
    	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
    	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
    	 */
    	function toVLQSigned(aValue) {
    	  return aValue < 0
    	    ? ((-aValue) << 1) + 1
    	    : (aValue << 1) + 0;
    	}

    	/**
    	 * Converts to a two-complement value from a value where the sign bit is
    	 * placed in the least significant bit.  For example, as decimals:
    	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
    	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
    	 */
    	function fromVLQSigned(aValue) {
    	  var isNegative = (aValue & 1) === 1;
    	  var shifted = aValue >> 1;
    	  return isNegative
    	    ? -shifted
    	    : shifted;
    	}

    	/**
    	 * Returns the base 64 VLQ encoded value.
    	 */
    	exports.encode = function base64VLQ_encode(aValue) {
    	  var encoded = "";
    	  var digit;

    	  var vlq = toVLQSigned(aValue);

    	  do {
    	    digit = vlq & VLQ_BASE_MASK;
    	    vlq >>>= VLQ_BASE_SHIFT;
    	    if (vlq > 0) {
    	      // There are still more digits in this value, so we must make sure the
    	      // continuation bit is marked.
    	      digit |= VLQ_CONTINUATION_BIT;
    	    }
    	    encoded += base64.encode(digit);
    	  } while (vlq > 0);

    	  return encoded;
    	};

    	/**
    	 * Decodes the next base 64 VLQ value from the given string and returns the
    	 * value and the rest of the string via the out parameter.
    	 */
    	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    	  var strLen = aStr.length;
    	  var result = 0;
    	  var shift = 0;
    	  var continuation, digit;

    	  do {
    	    if (aIndex >= strLen) {
    	      throw new Error("Expected more digits in base 64 VLQ value.");
    	    }

    	    digit = base64.decode(aStr.charCodeAt(aIndex++));
    	    if (digit === -1) {
    	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    	    }

    	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    	    digit &= VLQ_BASE_MASK;
    	    result = result + (digit << shift);
    	    shift += VLQ_BASE_SHIFT;
    	  } while (continuation);

    	  aOutParam.value = fromVLQSigned(result);
    	  aOutParam.rest = aIndex;
    	};


    /***/ }),
    /* 6 */
    /***/ (function(module, exports) {

    	/* -*- Mode: js; js-indent-level: 2; -*- */
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

    	/**
    	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
    	 */
    	exports.encode = function (number) {
    	  if (0 <= number && number < intToCharMap.length) {
    	    return intToCharMap[number];
    	  }
    	  throw new TypeError("Must be between 0 and 63: " + number);
    	};

    	/**
    	 * Decode a single base 64 character code digit to an integer. Returns -1 on
    	 * failure.
    	 */
    	exports.decode = function (charCode) {
    	  var bigA = 65;     // 'A'
    	  var bigZ = 90;     // 'Z'

    	  var littleA = 97;  // 'a'
    	  var littleZ = 122; // 'z'

    	  var zero = 48;     // '0'
    	  var nine = 57;     // '9'

    	  var plus = 43;     // '+'
    	  var slash = 47;    // '/'

    	  var littleOffset = 26;
    	  var numberOffset = 52;

    	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    	  if (bigA <= charCode && charCode <= bigZ) {
    	    return (charCode - bigA);
    	  }

    	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
    	  if (littleA <= charCode && charCode <= littleZ) {
    	    return (charCode - littleA + littleOffset);
    	  }

    	  // 52 - 61: 0123456789
    	  if (zero <= charCode && charCode <= nine) {
    	    return (charCode - zero + numberOffset);
    	  }

    	  // 62: +
    	  if (charCode == plus) {
    	    return 62;
    	  }

    	  // 63: /
    	  if (charCode == slash) {
    	    return 63;
    	  }

    	  // Invalid base64 digit.
    	  return -1;
    	};


    /***/ }),
    /* 7 */
    /***/ (function(module, exports) {

    	/* -*- Mode: js; js-indent-level: 2; -*- */
    	/*
    	 * Copyright 2011 Mozilla Foundation and contributors
    	 * Licensed under the New BSD license. See LICENSE or:
    	 * http://opensource.org/licenses/BSD-3-Clause
    	 */

    	// It turns out that some (most?) JavaScript engines don't self-host
    	// `Array.prototype.sort`. This makes sense because C++ will likely remain
    	// faster than JS when doing raw CPU-intensive sorting. However, when using a
    	// custom comparator function, calling back and forth between the VM's C++ and
    	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
    	// worse generated code for the comparator function than would be optimal. In
    	// fact, when sorting with a comparator, these costs outweigh the benefits of
    	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
    	// a ~3500ms mean speed-up in `bench/bench.html`.

    	/**
    	 * Swap the elements indexed by `x` and `y` in the array `ary`.
    	 *
    	 * @param {Array} ary
    	 *        The array.
    	 * @param {Number} x
    	 *        The index of the first item.
    	 * @param {Number} y
    	 *        The index of the second item.
    	 */
    	function swap(ary, x, y) {
    	  var temp = ary[x];
    	  ary[x] = ary[y];
    	  ary[y] = temp;
    	}

    	/**
    	 * Returns a random integer within the range `low .. high` inclusive.
    	 *
    	 * @param {Number} low
    	 *        The lower bound on the range.
    	 * @param {Number} high
    	 *        The upper bound on the range.
    	 */
    	function randomIntInRange(low, high) {
    	  return Math.round(low + (Math.random() * (high - low)));
    	}

    	/**
    	 * The Quick Sort algorithm.
    	 *
    	 * @param {Array} ary
    	 *        An array to sort.
    	 * @param {function} comparator
    	 *        Function to use to compare two items.
    	 * @param {Number} p
    	 *        Start index of the array
    	 * @param {Number} r
    	 *        End index of the array
    	 */
    	function doQuickSort(ary, comparator, p, r) {
    	  // If our lower bound is less than our upper bound, we (1) partition the
    	  // array into two pieces and (2) recurse on each half. If it is not, this is
    	  // the empty array and our base case.

    	  if (p < r) {
    	    // (1) Partitioning.
    	    //
    	    // The partitioning chooses a pivot between `p` and `r` and moves all
    	    // elements that are less than or equal to the pivot to the before it, and
    	    // all the elements that are greater than it after it. The effect is that
    	    // once partition is done, the pivot is in the exact place it will be when
    	    // the array is put in sorted order, and it will not need to be moved
    	    // again. This runs in O(n) time.

    	    // Always choose a random pivot so that an input array which is reverse
    	    // sorted does not cause O(n^2) running time.
    	    var pivotIndex = randomIntInRange(p, r);
    	    var i = p - 1;

    	    swap(ary, pivotIndex, r);
    	    var pivot = ary[r];

    	    // Immediately after `j` is incremented in this loop, the following hold
    	    // true:
    	    //
    	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    	    //
    	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    	    for (var j = p; j < r; j++) {
    	      if (comparator(ary[j], pivot) <= 0) {
    	        i += 1;
    	        swap(ary, i, j);
    	      }
    	    }

    	    swap(ary, i + 1, j);
    	    var q = i + 1;

    	    // (2) Recurse on each half.

    	    doQuickSort(ary, comparator, p, q - 1);
    	    doQuickSort(ary, comparator, q + 1, r);
    	  }
    	}

    	/**
    	 * Sort the given array in-place with the given comparator function.
    	 *
    	 * @param {Array} ary
    	 *        An array to sort.
    	 * @param {function} comparator
    	 *        Function to use to compare two items.
    	 */
    	exports.quickSort = function (ary, comparator) {
    	  doQuickSort(ary, comparator, 0, ary.length - 1);
    	};


    /***/ })
    /******/ ])
    });
    });

    // eslint-disable-next-line @typescript-eslint/no-empty-function
    var noop = function () { };
    var makeQueryParams = function (session, offset, failed, skipped, retry) {
        if (offset > 0 || retry > 0 || skipped > 0) {
            var rt = (retry > 0 ? '&retry=' + retry : '');
            var sk = (skipped > 0 ? '&skipped=' + skipped : '');
            return '?session=' + session + '&offset=' + offset + '&failed=' + failed + sk + rt;
        }
        else {
            return '';
        }
    };
    var makeUrl = function (session, offset, failed, skipped, retry) {
        var baseUrl = window.location.protocol + '//' + window.location.host + window.location.pathname;
        return baseUrl + makeQueryParams(session, offset, failed, skipped, retry);
    };
    var formatElapsedTime = function (start, end) {
        var millis = end.getTime() - start.getTime();
        var seconds = Math.floor(millis / 1000);
        var point = Math.floor(millis - (seconds * 1000) / 100);
        var printable = point < 10 ? '00' + point :
            point < 100 ? '0' + point :
                '' + point;
        return seconds + '.' + printable + 's';
    };
    var getFullTitle = function (suiteOrTest, separator) {
        var _a;
        var parentTitle = (_a = suiteOrTest.parent) === null || _a === void 0 ? void 0 : _a.fullTitle();
        if (parentTitle !== undefined && parentTitle.length > 0) {
            return "".concat(parentTitle, " ").concat(separator, " ").concat(suiteOrTest.title);
        }
        else {
            return suiteOrTest.title;
        }
    };
    var makeSessionId = function () { return '' + Math.ceil((Math.random() * 100000000)); };
    var mapStackTrace = function (stack) { return new Promise(function (resolve) {
        if (stack) {
            // If the stack trace format can't be found then an Error will be thrown.
            // In that case lets just return the original stack instead.
            try {
                sourcemappedStacktrace.mapStackTrace(stack, function (stack) { return resolve(stack.join('\n')); });
            }
            catch (e) {
                resolve(stack);
            }
        }
        else {
            resolve('');
        }
    }); };
    var setStack = function (error, stack) {
        try {
            error.stack = stack;
        }
        catch (err) {
            // Do nothing
        }
    };

    var create = function (title, root, parent) {
        var _a;
        var suite = {
            title: title,
            hooks: (_a = {},
                _a["before" /* Before */] = [],
                _a["beforeEach" /* BeforeEach */] = [],
                _a["after" /* After */] = [],
                _a["afterEach" /* AfterEach */] = [],
                _a),
            root: root,
            suites: [],
            tests: [],
            parent: parent,
            _only: false,
            _skip: false,
            isSkipped: function () {
                return suite._skip || (parent === null || parent === void 0 ? void 0 : parent.isSkipped()) === true;
            },
            fullTitle: function () { return getFullTitle(suite, '/'); }
        };
        return suite;
    };
    var createSuite = function (title, parent) {
        return create(title, false, parent);
    };
    var createRootSuite = function (title) {
        return create(title, true);
    };

    var __assign$1 = (window && window.__assign) || function () {
        __assign$1 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };
    var createTest = function (title, fn, parent) {
        var runnable = createRunnable(title, fn);
        var test = __assign$1(__assign$1({}, runnable), { parent: parent, _only: false, setResult: function (state, e) {
                runnable.setResult(state, e);
                test.error = e;
            }, isSkipped: function () {
                return runnable.isSkipped() || (parent === null || parent === void 0 ? void 0 : parent.isSkipped()) === true;
            }, fullTitle: function () { return getFullTitle(test, '-'); } });
        return test;
    };

    var root = createRootSuite('');
    var suiteStack = [root];
    var getCurrentSuite = function () {
        return suiteStack.length > 0 ? suiteStack[suiteStack.length - 1] : undefined;
    };
    var getCurrentSuiteOrDie = function () {
        var currentSuite = getCurrentSuite();
        if (currentSuite === undefined) {
            throw new Error('Failed to find a current test suite');
        }
        else {
            return currentSuite;
        }
    };
    /*
      Mocha allows a mix of different overloads when registering hooks, so we need to account for them. The following are known:
      - (title: string, fn: ExecuteFn) => void
      - (title: undefined, fn: ExecuteFn) => void
      - (title: string) => void
      - (fn: ExecuteFn) => void
     */
    var addHook = function (suite, type, title, fn) {
        var hookTitle = typeof title === 'string' ? "".concat(type, ": ").concat(title) : type;
        var hookFn = typeof title === 'function' ? title : fn;
        var hook = createHook(hookTitle, hookFn);
        suite.hooks[type].push(hook);
    };
    var describe = function (title, fn) {
        var current = getCurrentSuiteOrDie();
        var suite = createSuite(title, current);
        current.suites.push(suite);
        suiteStack.push(suite);
        fn.call(suite);
        suiteStack.pop();
        return suite;
    };
    describe.only = function (title, fn) {
        var suite = describe(title, fn);
        suite._only = true;
        return suite;
    };
    describe.skip = function (title, fn) {
        var suite = describe(title, fn);
        suite._skip = true;
        return suite;
    };
    var before = function (title, fn) {
        var suite = getCurrentSuiteOrDie();
        addHook(suite, "before" /* Before */, title, fn);
    };
    var beforeEach = function (title, fn) {
        var suite = getCurrentSuiteOrDie();
        addHook(suite, "beforeEach" /* BeforeEach */, title, fn);
    };
    var after = function (title, fn) {
        var suite = getCurrentSuiteOrDie();
        addHook(suite, "after" /* After */, title, fn);
    };
    var afterEach = function (title, fn) {
        var suite = getCurrentSuiteOrDie();
        addHook(suite, "afterEach" /* AfterEach */, title, fn);
    };
    var it = function (title, fn) {
        var suite = getCurrentSuiteOrDie();
        var test$1 = createTest(title, fn, suite);
        suite.tests.push(test$1);
        test(test$1);
        return test$1;
    };
    it.only = function (title, fn) {
        var test = it(title, fn);
        test._only = true;
        return test;
    };
    it.skip = function (title, fn) {
        var test = it(title, fn);
        test.setResult("skipped" /* Skipped */);
        return test;
    };
    var setup = function (global) {
        if (global === void 0) { global = Global; }
        var globals = {
            before: before,
            beforeEach: beforeEach,
            after: after,
            afterEach: afterEach,
            describe: describe,
            xdescribe: describe.skip,
            context: describe,
            xcontext: describe.skip,
            it: it,
            xit: it.skip,
            specify: it,
            xspecify: it.skip
        };
        var keys = Object.keys(globals);
        keys.forEach(function (key) {
            global[key] = globals[key];
        });
    };
    var rootSuite = function () { return root; };

    // instanceof doesn't work with cross frame errors so we need
    // to rely on duck-typing to check if we have an error
    var isError = function (e) {
        return isObject(e) && (e instanceof Error ||
            isString(e.message) && isString(e.stack));
    };
    var ErrorCatcher = function () {
        var supportsGlobalEventListeners = Global.addEventListener !== undefined;
        var onErrorHandlers = new Set();
        var bound = false;
        var createHandler = function (extractError) { return function (e) {
            if (onErrorHandlers.size > 0) {
                var error_1 = extractError(e);
                onErrorHandlers.forEach(function (onError) { return onError(error_1); });
                e.preventDefault();
                return false;
            }
            else {
                return true;
            }
        }; };
        var onUnhandledRejection = createHandler(function (e) {
            if (isError(e.reason)) {
                var error = new Error("Unhandled promise rejection: ".concat(e.reason.message));
                setStack(error, e.reason.stack);
                return error;
            }
            else {
                return new Error("Unhandled promise rejection: ".concat(e.reason));
            }
        });
        var onUncaughtError = createHandler(function (e) {
            if (isError(e.error)) {
                if (isInternalError(e.error)) {
                    return e.error;
                }
                else {
                    var error = new Error(e.message);
                    setStack(error, e.error.stack);
                    return error;
                }
            }
            else {
                return new Error("".concat(e.message, " (").concat(e.filename, ":").concat(e.lineno, ")"));
            }
        });
        var bind = function () {
            if (supportsGlobalEventListeners && !bound) {
                bound = true;
                Global.addEventListener('error', onUncaughtError);
                Global.addEventListener('unhandledrejection', onUnhandledRejection);
            }
        };
        var unbind = function () {
            if (bound) {
                bound = false;
                Global.removeEventListener('error', onUncaughtError);
                Global.removeEventListener('unhandledrejection', onUnhandledRejection);
            }
        };
        var addHandler = function (onError) {
            onErrorHandlers.add(onError);
            bind();
            return {
                unbind: function () { return onErrorHandlers.delete(onError); }
            };
        };
        return {
            bind: addHandler,
            destroy: unbind
        };
    };

    var load = function (scriptUrl) {
        return new Promise(function (resolve, reject) {
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = scriptUrl;
            // Setup the error catcher to handle syntax errors or similar in the scripts
            var errorCatcher = ErrorCatcher();
            var cleanup = function () {
                script.removeEventListener('load', success);
                script.removeEventListener('error', failure);
                errorCatcher.destroy();
                document.body.removeChild(script);
            };
            var success = function () {
                cleanup();
                resolve();
            };
            var failure = function (e) {
                cleanup();
                if (e instanceof Event) {
                    reject(new Error("Failed to load script: ".concat(scriptUrl)));
                }
                else {
                    reject(e);
                }
            };
            // Bind the events
            errorCatcher.bind(failure);
            script.addEventListener('load', success);
            script.addEventListener('error', failure);
            // Add the script to the dom to load it
            document.body.appendChild(script);
        });
    };

    /**
     * Decode a URI encoded string.
     *
     * @param {String} input The URI encoded string.
     * @returns {String|Null} The decoded string.
     * @api private
     */
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, ' '));
      } catch (e) {
        return null;
      }
    }

    /**
     * Simple query string parser.
     *
     * @param {String} query The query string that needs to be parsed.
     * @returns {Object}
     * @api public
     */
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g
        , result = {}
        , part;

      while (part = parser.exec(query)) {
        var key = decode(part[1])
          , value = decode(part[2]);

        //
        // Prevent overriding of existing properties. This ensures that build-in
        // methods like `toString` or __proto__ are not overriden by malicious
        // querystrings.
        //
        // In the case if failed decoding, we want to omit the key/value pairs
        // from the result.
        //
        if (key === null || value === null || key in result) continue;
        result[key] = value;
      }

      return result;
    }
    var parse = querystring;

    var nat = function (str) {
        if (typeof str === 'string') {
            var num = parseInt(str, 10);
            if (!isNaN(num) && num > 0) {
                return num;
            }
        }
        return 0;
    };
    var parse$1 = function (search, makeSessionId) {
        var params = parse(search);
        return {
            session: params.session || makeSessionId(),
            offset: nat(params.offset),
            failed: nat(params.failed),
            skipped: nat(params.skipped),
            retry: nat(params.retry),
        };
    };
    var UrlParams = {
        parse: parse$1,
        nat: nat
    };

    var sendJson = function (url, data) {
        return new Promise(function (onSuccess, onError) {
            $.ajax({
                method: 'post',
                url: url,
                contentType: 'application/json; charset=UTF-8',
                dataType: 'json',
                success: onSuccess,
                error: function (xhr, statusText, e) {
                    onError(e);
                },
                data: JSON.stringify(data),
            });
        });
    };
    var getJson = function (url) {
        return new Promise((function (onSuccess, onError) {
            $.ajax({
                url: url,
                dataType: 'json',
                success: onSuccess,
                error: function (xhr, statusText, e) {
                    onError(e);
                }
            });
        }));
    };
    var Callbacks = function () {
        var loadHarness = function () {
            return getJson('harness');
        };
        var sendInit = function (session) {
            return sendJson('/tests/init', {
                session: session,
            });
        };
        var sendKeepAlive = function (session) {
            return sendJson('/tests/alive', {
                session: session,
            });
        };
        var sendTestStart = function (session, totalTests, file, name) {
            return sendJson('/tests/start', {
                totalTests: totalTests,
                session: session,
                file: file,
                name: name,
            });
        };
        var sendTestResult = function (session, file, name, passed, time, error, skipped) {
            return sendJson('/tests/result', {
                session: session,
                file: file,
                name: name,
                passed: passed,
                skipped: skipped,
                time: time,
                error: error,
            });
        };
        var sendDone = function (session, error) {
            // webpack makes this available
            var getCoverage = function () { return typeof Global.__coverage__ === 'undefined' ? {} : Global.__coverage__; };
            return sendJson('/tests/done', {
                session: session,
                error: error,
                coverage: getCoverage(),
            });
        };
        return {
            loadHarness: loadHarness,
            sendInit: sendInit,
            sendKeepAlive: sendKeepAlive,
            sendTestStart: sendTestStart,
            sendTestResult: sendTestResult,
            sendDone: sendDone
        };
    };

    var elapsed = function (since) { return formatElapsedTime(since, new Date()); };
    var mapError = function (e) { return mapStackTrace(e.stack).then(function (mappedStack) {
        var originalStack = e.stack;
        setStack(e, mappedStack);
        // Logs may have the stack trace included as well, so ensure we replace that as well
        if (e.logs !== undefined && e.logs.length > 0 && originalStack !== undefined) {
            var logs = e.logs.join('\n');
            e.logs = logs.replace(originalStack, mappedStack).split('\n');
        }
        return Promise.resolve(e);
    }); };
    var Reporter = function (params, callbacks, ui) {
        var initial = new Date();
        var currentCount = params.offset || 0;
        var passCount = 0;
        var skipCount = 0;
        var failCount = 0;
        var summary = function () { return ({
            offset: Math.max(0, currentCount - 1),
            passed: passCount + (params.offset - params.failed - params.skipped),
            failed: failCount + params.failed,
            skipped: skipCount + params.skipped
        }); };
        var test = function (file, name, totalNumTests) {
            var starttime;
            var reported = false;
            var started = false;
            var testUi = ui.test();
            var start = function () {
                if (started) {
                    return Promise.resolve();
                }
                else {
                    started = true;
                    starttime = new Date();
                    currentCount++;
                    testUi.start(file, name);
                    return callbacks.sendTestStart(params.session, totalNumTests, file, name);
                }
            };
            var retry = function () {
                starttime = new Date();
                return Promise.resolve();
            };
            var pass = function () {
                if (reported) {
                    return Promise.resolve();
                }
                else {
                    reported = true;
                    passCount++;
                    var testTime = elapsed(starttime);
                    testUi.pass(testTime, currentCount);
                    return callbacks.sendTestResult(params.session, file, name, true, testTime, null, null);
                }
            };
            var skip = function (reason) {
                if (reported) {
                    return Promise.resolve();
                }
                else {
                    reported = true;
                    skipCount++;
                    var testTime = elapsed(starttime);
                    testUi.skip(testTime, currentCount);
                    return callbacks.sendTestResult(params.session, file, name, false, testTime, null, reason);
                }
            };
            var fail = function (e) {
                if (reported) {
                    return Promise.resolve();
                }
                else {
                    reported = true;
                    failCount++;
                    var testTime_1 = elapsed(starttime);
                    return mapError(e).then(function (err) {
                        var errorData = data(err);
                        var error = {
                            data: errorData,
                            text: dataText(errorData)
                        };
                        testUi.fail(err, testTime_1, currentCount);
                        return callbacks.sendTestResult(params.session, file, name, false, testTime_1, error, null);
                    });
                }
            };
            return {
                start: start,
                retry: retry,
                pass: pass,
                skip: skip,
                fail: fail
            };
        };
        var done = function (error) {
            var setAsDone = function () {
                var totalTime = elapsed(initial);
                ui.done(totalTime);
            };
            var textError = error !== undefined ? text(error) : undefined;
            callbacks.sendDone(params.session, textError).then(setAsDone, setAsDone);
        };
        return {
            summary: summary,
            test: test,
            done: done
        };
    };

    var Actions = function (session) {
        var reloadPage = function (offset, failed, skipped, retry) {
            if (retry === void 0) { retry = 0; }
            var url = makeUrl(session, offset, failed, skipped, retry);
            window.location.assign(url);
        };
        var updateHistory = function (offset, failed, skipped, retry) {
            if (retry === void 0) { retry = 0; }
            var url = makeUrl(session, offset, failed, skipped, retry);
            window.history.pushState({}, '', url);
        };
        return {
            restartTests: function () { return reloadPage(0, 0, 0); },
            retryTest: function (offset, failed, skipped, retry) { return reloadPage(offset, failed - 1, skipped, retry); },
            nextTest: function (offset, failed, skipped) { return reloadPage(offset + 1, failed, skipped); },
            reloadPage: reloadPage,
            updateHistory: updateHistory
        };
    };

    var createContext = function (runnable, currentTest) { return ({
        current: runnable,
        currentTest: currentTest,
        skip: runnable.skip,
        retries: runnable.retries,
        slow: runnable.slow,
        timeout: runnable.timeout
    }); };

    var Timer = function () {
        var timer;
        var timedOut = false;
        var callback = noop;
        var startTimer = function (ms) {
            timedOut = false;
            timer = setTimeout(function () {
                timedOut = true;
                callback();
            }, ms);
        };
        var stopTimer = function () {
            if (timer !== undefined) {
                clearTimeout(timer);
                timer = undefined;
            }
        };
        return {
            start: function (ms, timedOutCallback) {
                callback = timedOutCallback;
                startTimer(ms);
            },
            restart: function (ms) {
                stopTimer();
                startTimer(ms);
            },
            stop: function () {
                stopTimer();
                callback = noop;
            },
            hasTimedOut: function () { return timedOut; }
        };
    };

    var isPromiseLike = function (value) {
        return value !== undefined && value.then !== undefined;
    };
    var errorCatcher = ErrorCatcher();
    var runWithErrorCatcher = function (runnable, fn) {
        return new Promise(function (resolve, reject) {
            var errorOccurred = false;
            var catcher = errorCatcher.bind(function (e) {
                if (!errorOccurred) {
                    errorOccurred = true;
                    var err = isInternalError(e) ? e : prepFailure(e);
                    runnable.setResult("failed" /* Failed */, err);
                    reject(err);
                }
            });
            fn().then(function (result) {
                catcher.unbind();
                if (!errorOccurred) {
                    resolve(result);
                }
            }, function (e) {
                catcher.unbind();
                if (!errorOccurred) {
                    reject(e);
                }
            });
        });
    };
    var runExecFn = function (fn, context) {
        return new Promise(function (resolve, reject) {
            var doneCalled = false;
            var done = function (err) {
                if (doneCalled) {
                    throw new MultipleDone('done() called multiple times', err);
                }
                else if (err !== undefined) {
                    reject(prepFailure(err));
                }
                else {
                    resolve();
                }
                doneCalled = true;
            };
            try {
                // If the function has 1 or more arguments, it's using the async callback
                var retValue = fn.call(context, done);
                if (fn.length === 0) {
                    if (isPromiseLike(retValue)) {
                        retValue.then(function () { return done(); }, done);
                    }
                    else {
                        resolve();
                    }
                }
            }
            catch (e) {
                var err = isInternalError(e) ? e : prepFailure(e);
                reject(err);
            }
        });
    };
    var run = function (runnable, context) {
        // Ensure we don't run if we already have a result or don't have anything to run
        if (runnable.isFailed()) {
            return Promise.reject(runnable.error);
        }
        else if (runnable.isSkipped()) {
            return Promise.reject(new SkipError());
        }
        else if (runnable.fn === undefined) {
            return Promise.resolve();
        }
        else {
            return runExecFn(runnable.fn, context).catch(function (e) {
                // Update the runnable state when an error occurs
                if (e instanceof SkipError) {
                    runnable.setResult("skipped" /* Skipped */);
                }
                else {
                    runnable.setResult("failed" /* Failed */, e);
                }
                return Promise.reject(e);
            });
        }
    };
    var runWithCleanup = function (runnable, context, cleanup) {
        return run(runnable, context).then(cleanup, function (e) {
            cleanup();
            return Promise.reject(e);
        });
    };
    var runWithTimeout = function (runnable, context, defaultTimeout) {
        // Update the runnable timeout to use the default timeout if required
        if (runnable.timeout() === -1) {
            runnable.timeout(defaultTimeout);
        }
        // Run the execute function with a timeout if required
        if (runnable.timeout() <= 0) {
            return run(runnable, context);
        }
        else {
            return new Promise(function (resolve, reject) {
                var timer = Timer();
                var resolveIfNotTimedOut = function () {
                    if (!timer.hasTimedOut()) {
                        resolve();
                    }
                };
                // If the runnable sets a timeout while running then we need to restart the timer
                var unbind = runnable._onChange('timeout', timer.restart);
                // Start the timer
                timer.start(runnable.timeout(), function () {
                    unbind();
                    reject(prepFailure(new Error("Test ran too long - timeout of ".concat(runnable.timeout(), "ms exceeded"))));
                });
                // Run the execute function and clean up after it's completed
                runWithCleanup(runnable, context, function () {
                    timer.stop();
                    unbind();
                }).then(resolveIfNotTimedOut, reject);
            });
        }
    };

    var countTests = function (suite) {
        return suite.tests.length + suite.suites.reduce(function (acc, suite) { return acc + countTests(suite); }, 0);
    };
    var loop = function (items, fn, index) {
        if (index === void 0) { index = 0; }
        if (index < items.length) {
            return fn(items[index]).then(function () { return loop(items, fn, index + 1); });
        }
        else {
            return Promise.resolve();
        }
    };
    var hasOnly = function (suite) {
        var onlyTests = suite.tests.filter(function (test) { return test._only; });
        var onlySuites = suite.suites.filter(function (suite) { return suite._only; });
        if (onlyTests.length > 0 || onlySuites.length > 0) {
            return true;
        }
        else {
            // Check all the nested child suites
            return suite.suites.some(hasOnly);
        }
    };
    var filterOnly = function (suite) {
        var onlyTests = suite.tests.filter(function (test) { return test._only; });
        var onlySuites = suite.suites.filter(function (child) { return child._only || hasOnly(child); });
        if (onlyTests.length > 0) {
            suite.tests = onlyTests;
            suite.suites = [];
        }
        else if (onlySuites.length > 0) {
            suite.tests = [];
            suite.suites.forEach(filterOnly);
            suite.suites = onlySuites;
        }
    };

    var DEFAULT_HOOK_TIMEOUT = 2000;
    var getHooks = function (suite, type, includeParents) {
        if (suite.isSkipped()) {
            return [];
        }
        else {
            var hooks = suite.hooks[type];
            if (includeParents && suite.parent !== undefined) {
                var parentHooks = getHooks(suite.parent, type, includeParents);
                // Reverse the suite hook order for after hooks so it gets the suite hooks bottom up
                if (type === "after" /* After */ || type === "afterEach" /* AfterEach */) {
                    return hooks.concat(parentHooks);
                }
                else {
                    return parentHooks.concat(hooks);
                }
            }
            else {
                return hooks;
            }
        }
    };
    var handleSkippedHook = function (suite, type, currentTest) {
        if (type === "before" /* Before */) {
            suite.suites.forEach(function (childSuite) {
                childSuite._skip = true;
            });
            suite.tests.forEach(function (test) {
                test.setResult("skipped" /* Skipped */);
            });
        }
        else if (type === "beforeEach" /* BeforeEach */ && currentTest !== undefined) {
            currentTest.setResult("skipped" /* Skipped */);
        }
    };
    var runHooks = function (suite, type, runOnParents, currentTest) {
        var hooks = getHooks(suite, type, runOnParents);
        return loop(hooks, function (hook) {
            return runWithErrorCatcher(hook, function () { return runWithTimeout(hook, createContext(hook, currentTest), DEFAULT_HOOK_TIMEOUT); });
        }).catch(function (e) {
            if (e instanceof SkipError) {
                handleSkippedHook(suite, type, currentTest);
                return Promise.resolve();
            }
            else {
                return Promise.reject(e);
            }
        });
    };
    var runBefore = function (suite, currentTest) {
        return runHooks(suite, "before" /* Before */, false, currentTest);
    };
    var runAfter = function (suite, currentTest) {
        return runHooks(suite, "after" /* After */, false, currentTest);
    };
    var runBeforeEach = function (currentTest) {
        if (currentTest.parent !== undefined) {
            return runHooks(currentTest.parent, "beforeEach" /* BeforeEach */, true, currentTest);
        }
        else {
            return Promise.resolve();
        }
    };
    var runAfterEach = function (currentTest) {
        if (currentTest.parent !== undefined) {
            return runHooks(currentTest.parent, "afterEach" /* AfterEach */, true, currentTest);
        }
        else {
            return Promise.resolve();
        }
    };

    var runTestWithRetry = function (test, state, report, retryCount) {
        if (test.isSkipped()) {
            return Promise.reject(new SkipError());
        }
        else {
            var runAfterHooks = function (error) { return function (result) {
                return runAfterEach(test).then(function () { return error ? Promise.reject(result) : Promise.resolve(result); });
            }; };
            return runBeforeEach(test)
                .then(function () { return runWithErrorCatcher(test, function () { return runWithTimeout(test, createContext(test, test), state.timeout); }); })
                // Ensure we run the afterEach hooks no matter if the test failed
                .then(runAfterHooks(false), runAfterHooks(true))
                .catch(function (e) {
                if (retryCount < test.retries() && !isInternalError(e)) {
                    test.setResult("notrun" /* NotRun */);
                    return report.retry().then(function () { return runTestWithRetry(test, state, report, retryCount + 1); });
                }
                else {
                    return Promise.reject(e);
                }
            });
        }
    };
    var runTest = function (test, state, actions, reporter) {
        var fail = function (report, e) {
            test.setResult("failed" /* Failed */, e);
            console.error(e);
            return report.fail(e).then(actions.onFailure).then(function () { return Promise.reject(); });
        };
        var skip = function (report) {
            test.setResult("skipped" /* Skipped */);
            return report.skip(test.title).then(actions.onSkip);
        };
        var pass = function (report) {
            test.setResult("passed" /* Passed */);
            return report.pass().then(actions.onPass);
        };
        state.testCount++;
        if (state.testCount <= state.offset) {
            return Promise.resolve();
        }
        else if (state.testCount > state.offset + state.chunk) {
            actions.runNextChunk(state.offset + state.chunk);
            // Reject so no other tests are run
            return Promise.reject();
        }
        else {
            var report_1 = reporter.test(test.file || 'Unknown', test.fullTitle(), state.totalTests);
            actions.onStart(test);
            return report_1.start()
                .then(function () { return runTestWithRetry(test, state, report_1, 0); })
                .then(function () { return pass(report_1); }, function (e) {
                if (e instanceof SkipError) {
                    return skip(report_1);
                }
                else {
                    return fail(report_1, prepFailure(e));
                }
            });
        }
    };
    var runTests = function (tests, state, actions, reporter) {
        return loop(tests, function (test) { return runTest(test, state, actions, reporter); });
    };
    var runSuite = function (suite, state, actions, reporter) {
        var numTests = countTests(suite);
        if (state.testCount + numTests <= state.offset) {
            state.testCount += numTests;
            return Promise.resolve();
        }
        else {
            var runAfterHooks = function (error) { return function (result) {
                return runAfter(suite).then(function () { return error ? Promise.reject(result) : Promise.resolve(result); });
            }; };
            return runBefore(suite)
                .then(function () { return runTests(suite.tests, state, actions, reporter); })
                .then(function () { return runSuites(suite.suites, state, actions, reporter); })
                // Ensure we run the after hooks no matter if the tests/suites fail
                .then(runAfterHooks(false), runAfterHooks(true));
        }
    };
    var runSuites = function (suites, state, actions, reporter) {
        return loop(suites, function (suite) { return runSuite(suite, state, actions, reporter); });
    };

    // 5sec interval for the server to know the client hasn't disconnected
    // Note: The interval needs to be less than 10secs, otherwise the server will disconnect.
    //       See `Controller.ts` in the server.
    var KEEP_ALIVE_INTERVAL = 5000;
    var Runner = function (rootSuite, params, callbacks, reporter, ui) {
        var actions = Actions(params.session);
        var numTests = 0;
        var withSum = function (action, offset, failedOffset, skippedOffset) {
            if (offset === void 0) { offset = 0; }
            if (failedOffset === void 0) { failedOffset = 0; }
            if (skippedOffset === void 0) { skippedOffset = 0; }
            return function (retry) {
                var sum = reporter.summary();
                action(sum.offset + offset, sum.failed + failedOffset, sum.skipped + skippedOffset, retry);
            };
        };
        var runNextChunk = function (offset) {
            var sum = reporter.summary();
            actions.reloadPage(offset, sum.failed, sum.skipped);
        };
        var retryTest = withSum(actions.retryTest);
        var loadNextTest = withSum(actions.nextTest);
        var stopTest = withSum(actions.updateHistory, 0, -1);
        var onTestPass = function () {
            var sum = reporter.summary();
            if (params.retry > 0) {
                params.retry = 0;
                actions.updateHistory(params.offset, sum.failed, sum.skipped, params.retry);
            }
        };
        var onTestFailure = function (retries, stopOnFailure) {
            if (stopOnFailure) {
                reporter.done();
                // make it easy to restart at this test
                stopTest();
            }
            else if (params.retry < retries) {
                retryTest(params.retry + 1);
            }
            else {
                loadNextTest();
            }
        };
        var init = function () {
            // Filter the tests to ensure we have an accurate total test count
            filterOnly(rootSuite);
            numTests = countTests(rootSuite);
            // Render the initial UI
            ui.render(params.offset, numTests, actions.restartTests, retryTest, loadNextTest);
            // delay this ajax call until after the reporter status elements are in the page
            var keepAliveTimer = setInterval(function () {
                callbacks.sendKeepAlive(params.session).catch(function () {
                    // if the server shuts down stop trying to send messages
                    clearInterval(keepAliveTimer);
                });
            }, KEEP_ALIVE_INTERVAL);
            return callbacks.sendInit(params.session).then(function () { return callbacks.loadHarness(); });
        };
        var run = function (chunk, retries, timeout, stopOnFailure) {
            var runState = {
                totalTests: numTests,
                offset: params.offset,
                chunk: chunk,
                timeout: timeout,
                testCount: 0
            };
            var runActions = {
                onFailure: function () { return onTestFailure(retries, stopOnFailure); },
                onPass: onTestPass,
                onSkip: onTestPass,
                onStart: noop,
                runNextChunk: runNextChunk
            };
            ui.setStopOnFailure(stopOnFailure);
            return runSuite(rootSuite, runState, runActions, reporter)
                .then(function () {
                reporter.done();
                // for easy rerun reset the URL
                actions.updateHistory(0, 0, 0);
            }, function (e) {
                // An error handled by the test runner won't return an error object and will just reject.
                // So if we have an error, it means an unexpected/unhandled error occurred in the promise
                // chain. If we have no error then the runner has finished due to a test failure.
                if (e !== undefined) {
                    return Promise.reject(e);
                }
                else {
                    return Promise.resolve();
                }
            });
        };
        return {
            init: init,
            run: run
        };
    };

    var Ui = function (container) {
        var stopOnFailure = false;
        var ui;
        var current;
        var restartBtn;
        var retryBtn;
        var skipBtn;
        var render = function (offset, totalNumTests, onRestart, onRetry, onSkip) {
            ui = $('<div></div>');
            current = $('<span />').addClass('progress').text(offset);
            restartBtn = $('<button />').text('Restart').on('click', onRestart);
            retryBtn = $('<button />').text('Retry').on('click', onRetry).hide();
            skipBtn = $('<button />').text('Skip').on('click', onSkip).hide();
            ui.append($('<div />')
                .append($('<span />').text('Suite progress: '))
                .append(current)
                .append($('<span />').text('/'))
                .append($('<span />').text(totalNumTests))
                .append('&nbsp;&nbsp;&nbsp;')
                .append(restartBtn)
                .append('&nbsp;&nbsp;&nbsp;')
                .append(retryBtn)
                .append('&nbsp;&nbsp;&nbsp;')
                .append(skipBtn));
            container.append(ui);
        };
        var done = function (totalTime) {
            ui.append('<div class="done">Test run completed in <span class="time">' + totalTime + '</span></div>');
            $('.passed.hidden,.skipped.hidden').removeClass('hidden');
        };
        var test = function () {
            var el;
            var marker;
            var errorContainer;
            var time;
            var start = function (file, name) {
                el = $('<div />').addClass('test running');
                var output = $('<div />').addClass('output');
                var testfile = $('<span />').text(file).addClass('testfile');
                var nameSpan = $('<span />').text(name).addClass('name');
                marker = $('<span />').text('[running]').addClass('result');
                errorContainer = $('<span />').addClass('error-container');
                time = $('<span />').addClass('time');
                output.append(marker, ' ', nameSpan, ' [', time, '] ', errorContainer, ' ', testfile);
                el.append(output);
                ui.append(el);
            };
            var pass = function (testTime, currentCount) {
                el.removeClass('running').addClass('passed').addClass('hidden');
                marker.text('[passed]').addClass('passed');
                time.text(testTime);
                current.text(currentCount);
            };
            var skip = function (testTime, currentCount) {
                el.removeClass('running').addClass('skipped').addClass('hidden');
                marker.text('[skipped]').addClass('skipped');
                time.text(testTime);
                current.text(currentCount);
            };
            var fail = function (e, testTime, currentCount) {
                el.removeClass('running').addClass('failed');
                marker.text('[failed]').addClass('failed');
                // Don't use .text() as it strips out newlines in IE, even when used
                // on a pre tag.
                var htmlError = html(e);
                var pre = $('<pre/>')
                    .addClass('error')
                    .html(htmlError);
                errorContainer.append(pre);
                time.text(testTime);
                current.text(currentCount);
                if (stopOnFailure) {
                    current.text('\u274c @ ' + current.text());
                    retryBtn.show();
                    skipBtn.show();
                }
            };
            return {
                start: start,
                pass: pass,
                skip: skip,
                fail: fail
            };
        };
        var error = function (error) {
            var message = html(error);
            ui.append("<div class=\"failed\"><pre>".concat(message, "</pre></div>"));
        };
        var setStopOnFailure = function (flag) {
            stopOnFailure = flag;
        };
        return {
            render: render,
            test: test,
            error: error,
            done: done,
            hideSkip: function () { return skipBtn.hide(); },
            showSkip: function () { return skipBtn.show(); },
            hideRetry: function () { return retryBtn.show(); },
            showRetry: function () { return retryBtn.show(); },
            setStopOnFailure: setStopOnFailure
        };
    };

    // Setup the globals
    setup();
    var setupAndRun = function (loadError) {
        var params = UrlParams.parse(window.location.search, makeSessionId);
        var ui = Ui($('body'));
        var callbacks = Callbacks();
        var reporter = Reporter(params, callbacks, ui);
        var runner = Runner(rootSuite(), params, callbacks, reporter, ui);
        runner.init().then(function (data) {
            if (data.mode === 'auto') {
                // Try to ensure the page has focus
                window.focus();
            }
            // Run the tests if an error didn't occur during loading
            if (loadError !== undefined) {
                return Promise.reject(loadError);
            }
            else {
                return runner.run(data.chunk, data.retries, data.timeout, data.stopOnFailure);
            }
        }).catch(function (e) {
            console.error('Unexpected error occurred', e);
            var err = prepFailure(e);
            ui.error(err);
            reporter.done(err);
        });
    };
    var run$1 = function () { return setupAndRun(); };
    var runError = function (e) { return setupAndRun(e); };
    var loadAndRun = function (scripts) {
        // Load the scripts and then run
        loop(scripts, load)
            .then(run$1, runError);
    };
    Global.bedrock = {
        loadAndRun: loadAndRun,
        run: run$1,
        rootSuite: rootSuite()
    };

}());
