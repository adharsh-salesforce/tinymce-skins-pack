"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.files = exports.directory = exports.positiveInteger = exports.any = exports.inSet = exports.file = void 0;
const fs = require("fs");
const glob = require("glob");
const readdirSyncRec = require("recursive-readdir-sync");
const Attempt_1 = require("../core/Attempt");
const Qstring = require("../util/Qstring");
const file = (name, rawValue) => {
    // Ignore any query strings when checking if a file exists
    const parsed = Qstring.parse(rawValue);
    const value = parsed.base;
    try {
        fs.accessSync(value);
        if (!fs.statSync(value).isFile()) {
            return Attempt_1.Attempt.failed([`Property: ${name} => Value: ${value} was not a file`]);
        }
        return Attempt_1.Attempt.passed(parsed.original);
    }
    catch (err) {
        return Attempt_1.Attempt.failed([`Property [${name}] has value: [${value}]. This file does not exist`]);
    }
};
exports.file = file;
const inSet = (candidates) => {
    return (name, value) => {
        if (candidates.indexOf(value) === -1) {
            return Attempt_1.Attempt.failed([
                `Invalid value for property: ${name}. Actual value: ${value}. Required value: one of ${JSON.stringify(candidates)}`
            ]);
        }
        else {
            return Attempt_1.Attempt.passed(value);
        }
    };
};
exports.inSet = inSet;
const any = (name, value) => {
    return Attempt_1.Attempt.passed(value);
};
exports.any = any;
const positiveInteger = (name, value) => {
    const failed = Attempt_1.Attempt.failed([`Invalid value for property: ${name}: [${value}] is not a positive integer`]);
    if (!Number.isInteger(value)) {
        return failed;
    }
    const n = Number(value);
    if (n <= 0) {
        return failed;
    }
    else {
        return Attempt_1.Attempt.passed(n);
    }
};
exports.positiveInteger = positiveInteger;
const directory = (name, value) => {
    try {
        if (!fs.lstatSync(value).isDirectory()) {
            return Attempt_1.Attempt.failed([`[${value}] is not a directory`]);
        }
        else {
            return Attempt_1.Attempt.passed(value);
        }
    }
    catch (err) {
        return Attempt_1.Attempt.failed([`[${value}] is not a directory`]);
    }
};
exports.directory = directory;
const files = (patterns) => {
    return (name, value) => {
        const dirs = glob.sync(value);
        if (dirs.length === 0) {
            return Attempt_1.Attempt.failed([`[${value}] does not match any directories`]);
        }
        else {
            try {
                const scanned = dirs.reduce((result, d) => result.concat(readdirSyncRec(d)), []);
                const filtered = scanned.filter((f) => {
                    const matches = patterns.filter((p) => {
                        return f.indexOf(p) > -1;
                    });
                    return matches.length > 0 && fs.lstatSync(f).isFile();
                });
                return Attempt_1.Attempt.passed(filtered);
            }
            catch (err) {
                return Attempt_1.Attempt.failed([
                    `Error scanning [${value}] for files matching pattern: [${patterns.join(', ')}]`
                ]);
            }
        }
    };
};
exports.files = files;
//# sourceMappingURL=Extraction.js.map