"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateImports = exports.convertPolyfillNameToPath = void 0;
const path = require("path");
const TsUtils_1 = require("./TsUtils");
const convertPolyfillNameToPath = (name) => {
    const path = name.slice(0, 1).toLowerCase() +
        name.slice(1).replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
    return `core-js/es/${path}`;
};
exports.convertPolyfillNameToPath = convertPolyfillNameToPath;
const filePathToImport = (useRequire, scratchFile) => {
    return (filePath) => {
        let relativePath = path.relative(path.dirname(scratchFile), filePath);
        // make sure backslashes are replaced for windows, as import paths should always use forward slashes
        relativePath = relativePath.replace(/\\/g, '/');
        // make sure backslashes are replaced with forward slash for the UI and JSON output string.
        filePath = filePath.replace(/\\/g, '/');
        const importString = useRequire ? `require("${relativePath}");` : `import "${relativePath}";`;
        return `
__currentTestFile = "${filePath}";
${importString}
addTest("${filePath}");`;
    };
};
const generatePolyfillImport = (useRequire, importPath) => {
    return useRequire ? `require('${importPath}');` : `import '${importPath}';`;
};
const generatePolyfills = (useRequire, polyfills) => {
    const polyfillImports = [];
    Object.keys(polyfills).forEach((name) => {
        const path = polyfills[name];
        polyfillImports.push(`if (window['${name}'] === undefined) {
  ${generatePolyfillImport(useRequire, path)}
}`);
    });
    return polyfillImports.join('\n');
};
const generateImportsTs = (useRequire, scratchFile, srcFiles, polyfills) => {
    const imports = srcFiles.map(filePathToImport(useRequire, scratchFile)).join('\n');
    // header code for tests.ts
    return `${generatePolyfills(useRequire, polyfills)}

declare let require: any;
declare let __tests: any[];
declare let console: any;
let __lastTestIndex: number = -1;
let __currentTestFile: string;
const addTest = (testFilePath: string) => {
  if (typeof __tests !== 'undefined' && __tests[__tests.length - 1]) {
    const lastTest = __tests[__tests.length - 1];
    if (!lastTest.file) {
      const tests = __tests.slice(__lastTestIndex + 1);
      tests.forEach((test: any) => {
        test.file = testFilePath;
      });
    } else if (lastTest.file === testFilePath) {
      // repeated test, duplicate the test entry
      __tests.push(__tests.slice(__lastTestIndex + 1));
    } else {
      console.warn('file ' + testFilePath + ' did not add a new test to the list, ignoring');
    }

    // Save the last test index
    __lastTestIndex = __tests.length - 1;
  } else {
    console.error('no test list to add tests to');
  }
};

const importErrorHandler = (event: any) => { 
  ${useRequire ? 'const UnitTest = require(\'@ephox/bedrock-client\').UnitTest;' : 'import { UnitTest } from \'@ephox/bedrock-client\';'}
  UnitTest.test('Error', () => {
    if (event.error) {
      throw event.error;
    } else {
      throw new Error(event.message);
    }
  });
  addTest(__currentTestFile);
};

window.addEventListener('error', importErrorHandler);
${imports}
window.removeEventListener('error', importErrorHandler);

export {};`;
};
const generateImportsJs = (useRequire, scratchFile, srcFiles, polyfills) => {
    const imports = srcFiles.map(filePathToImport(useRequire, scratchFile)).join('\n');
    // header code for tests-imports.js
    return `${generatePolyfills(useRequire, polyfills)}

var __lastTestIndex = -1;
var __currentTestFile;
var addTest = function (testFilePath) {
  if (typeof __tests !== 'undefined' && __tests[__tests.length - 1]) {
    var lastTest = __tests[__tests.length - 1];
    if (!lastTest.file) {
      var tests = __tests.slice(__lastTestIndex + 1);
      tests.forEach(function (test) {
        test.file = testFilePath;
      });
    } else if (lastTest.file === testFilePath) {
      // repeated test, duplicate the test entry
      __tests.push(__tests.slice(__lastTestIndex + 1));
    } else {
      console.warn('file ' + testFilePath + ' did not add a new test to the list, ignoring');
    }

    // Save the last test index
    __lastTestIndex = __tests.length - 1;
  } else {
    console.error('no test list to add tests to');
  }
};

var importErrorHandler = function (event) {
  ${useRequire ? 'var UnitTest = require(\'@ephox/bedrock-client\').UnitTest;' : 'import { UnitTest } from \'@ephox/bedrock-client\';'}
  UnitTest.test('Error', function () {
    if (event.error) {
      throw event.error;
    } else {
      throw new Error(event.message);
    }
  });
  addTest(__currentTestFile);
};

window.addEventListener('error', importErrorHandler);
${imports}
window.removeEventListener('error', importErrorHandler);

export {};`;
};
const generateImports = (useRequire, scratchFile, srcFiles, polyfills) => {
    const polyfillPaths = {};
    polyfills.forEach((name) => {
        polyfillPaths[name] = (0, exports.convertPolyfillNameToPath)(name);
    });
    const f = (0, TsUtils_1.hasTs)(srcFiles) ? generateImportsTs : generateImportsJs;
    return f(useRequire, scratchFile, srcFiles, polyfillPaths);
};
exports.generateImports = generateImports;
//# sourceMappingURL=Imports.js.map