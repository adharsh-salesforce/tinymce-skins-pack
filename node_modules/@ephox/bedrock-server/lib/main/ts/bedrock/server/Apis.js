"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = void 0;
const Attempt_1 = require("../core/Attempt");
const Coverage = require("../core/Coverage");
const Waiter = require("../util/Waiter");
const ClipboardEffects = require("./ClipboardEffects");
const Controller = require("./Controller");
const KeyEffects = require("./KeyEffects");
const MouseEffects = require("./MouseEffects");
const Routes = require("./Routes");
// This is how long to wait before checking if the driver is ready again
const pollRate = 200;
// This is how many times to fail the driver check before the process fails
const maxInvalidAttempts = 300;
// TODO: Do not use files here.
const create = (master, maybeDriver, projectdir, basedir, stickyFirstSession, singleTimeout, overallTimeout, testfiles, loglevel, resetMousePosition) => {
    let pageHasLoaded = false;
    let needsMousePositionReset = true;
    // On IE, the webdriver seems to load the page before it's ready to start
    // responding to commands. If the testing page itself tries to interact with
    // effects before driver.get has returned properly, it throws "UnsupportedOperationErrors"
    // This code is designed to allow the driver.get promise launched in bedrock-auto to
    // let the server known when it is able to use driver when responding to effect ajax calls.
    const waitForDriverReady = async (attempts, f) => {
        if (pageHasLoaded && master !== null) {
            return master.waitForIdle(f, 'effect');
        }
        else if (attempts === 0) {
            return Promise.reject('Driver never appeared to be ready');
        }
        else {
            await Waiter.delay({}, pollRate);
            return waitForDriverReady(attempts - 1, f);
        }
    };
    const effect = (executor, driver, effectChangesMouse) => {
        return (data) => {
            return waitForDriverReady(maxInvalidAttempts, () => {
                if (effectChangesMouse) {
                    needsMousePositionReset = true;
                }
                return executor(driver)(data);
            });
        };
    };
    const resetMousePositionAction = (force = false) => {
        if (resetMousePosition) {
            return Attempt_1.Attempt.cata(maybeDriver, () => Promise.reject('Resetting mouse position not supported without webdriver running. Use bedrock-auto to get this feature.'), (driver) => waitForDriverReady(maxInvalidAttempts, async () => {
                const shouldResetMousePos = force || needsMousePositionReset;
                // TODO re-enable resetting the mouse on other browsers when mouseMove gets fixed on Firefox/IE
                const browserName = driver.capabilities.browserName;
                if (shouldResetMousePos && (browserName === 'chrome' || browserName === 'msedge')) {
                    // Reset the mouse position to the top left of the window
                    await driver.performActions([{
                            type: 'pointer',
                            id: 'finger1',
                            parameters: { pointerType: 'mouse' },
                            actions: [{ type: 'pointerMove', duration: 0, x: 0, y: 0 }]
                        }]);
                    needsMousePositionReset = false;
                }
            }));
        }
        else {
            return Promise.resolve();
        }
    };
    const driverRouter = (url, apiLabel, executor, effectChangesMouse) => {
        return Attempt_1.Attempt.cata(maybeDriver, () => {
            return Routes.unsupported('POST', url, apiLabel + ' API not supported without webdriver running. Use bedrock-auto to get this feature.');
        }, (driver) => {
            return Routes.effect('POST', url, effect(executor, driver, effectChangesMouse));
        });
    };
    const markLoaded = () => {
        pageHasLoaded = true;
    };
    const c = Controller.create(stickyFirstSession, singleTimeout, overallTimeout, testfiles, loglevel);
    const routers = [
        driverRouter('/keys', 'Keys', KeyEffects.executor, false),
        driverRouter('/mouse', 'Mouse', MouseEffects.executor, true),
        Routes.effect('POST', '/tests/alive', (data) => {
            c.recordAlive(data.session);
            return Promise.resolve();
        }),
        Routes.effect('POST', '/tests/init', () => resetMousePositionAction(true)),
        Routes.effect('POST', '/tests/start', (data) => {
            c.recordTestStart(data.session, data.name, data.file, data.totalTests);
            return resetMousePositionAction();
        }),
        Routes.effect('POST', '/tests/result', (data) => {
            c.recordTestResult(data.session, data.name, data.file, data.passed, data.time, data.error, data.skipped);
            return Promise.resolve();
        }),
        Routes.effect('POST', '/tests/done', (data) => {
            Coverage.writeCoverageData(data.coverage);
            c.recordDone(data.session, data.error);
            return Promise.resolve();
        }),
        // This does not need the webdriver.
        Routes.effect('POST', '/clipboard', ClipboardEffects.route(basedir, projectdir))
    ];
    return {
        routers,
        markLoaded,
        enableHud: c.enableHud,
        awaitDone: c.awaitDone
    };
};
exports.create = create;
//# sourceMappingURL=Apis.js.map