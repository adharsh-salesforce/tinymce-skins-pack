"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = exports.startCustom = void 0;
const finalhandler = require("finalhandler");
const http = require("http");
const portfinder = require("portfinder");
const Routes = require("./Routes");
const Apis = require("./Apis");
const CustomRoutes = require("./CustomRoutes");
/*
 * Settings:
 *
 * projectdir: project directory (what you are testing)
 * basedir: the directory of bedrock
 * testfiles: the test files to test (an array)
 * driver: (optional). Required for supporting keys,
 * master (can be null) The driver master (locking and unlocking)
 * runner: runner (e.g. runnerroutes, pageroutes etc). Has fallback and routers.
 */
const startCustom = async (settings, createServer) => {
    const pref = (f) => {
        const v = settings[f];
        if (v === undefined) {
            throw new Error('Object: does not have field: ' + f);
        }
        return v;
    };
    const cr = CustomRoutes.create(settings.customRoutes);
    const basedir = pref('basedir');
    const projectdir = pref('projectdir');
    const testfiles = pref('testfiles');
    const maybeDriver = pref('driver');
    const master = pref('master');
    const stickyFirstSession = settings.stickyFirstSession;
    const singleTimeout = pref('singleTimeout');
    const overallTimeout = pref('overallTimeout');
    const resetMousePosition = !pref('skipResetMousePosition');
    const runner = pref('runner');
    const api = Apis.create(master, maybeDriver, projectdir, basedir, stickyFirstSession, singleTimeout, overallTimeout, testfiles, settings.loglevel, resetMousePosition);
    const routers = runner.routers.concat(api.routers, cr.routers);
    const fallback = runner.fallback;
    try {
        const port = await portfinder.getPortPromise({
            port: 8000,
            stopPort: 20000
        });
        const server = createServer(port, (request, response) => {
            const done = finalhandler(request, response);
            Routes.route(routers, fallback, request, response, done);
        });
        await server.start();
        return {
            port,
            markLoaded: api.markLoaded,
            enableHud: api.enableHud,
            awaitDone: api.awaitDone,
            shutdown: server.stop
        };
    }
    catch (err) {
        return Promise.reject('Error looking for open port between 8000 and 20000: ' + err);
    }
};
exports.startCustom = startCustom;
const start = (settings) => {
    return (0, exports.startCustom)(settings, (port, listener) => {
        const server = http.createServer(listener);
        return {
            start: () => {
                return new Promise((resolve) => {
                    server.listen(port, resolve);
                });
            },
            stop: () => new Promise((resolve, reject) => {
                server.close((err) => {
                    err ? reject(err) : resolve();
                });
            })
        };
    });
};
exports.start = start;
//# sourceMappingURL=Serve.js.map