"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.route = exports.unsupported = exports.hostOn = exports.host = exports.constant = exports.rewrite = exports.effect = exports.asyncJs = exports.json = exports.routing = void 0;
const server = require("serve-static");
const RouteUtils = require("../util/RouteUtils");
const Matchers = require("./Matchers");
const createServer = (root) => {
    // Note: The serve-static types appear to be wrong here, so just force it back to what it should be
    return server(root);
};
const doResponse = (request, response, status, contentType, data) => {
    response.setHeader('ETag', RouteUtils.generateETag(data));
    if (status === 304 || RouteUtils.isCachable(status) && RouteUtils.isFresh(request, response)) {
        response.writeHead(304, {});
        response.end();
    }
    else {
        response.writeHead(status, {
            'Content-Type': contentType,
            'Cache-Control': 'public, max-age=0'
        });
        response.end(data);
    }
};
const routing = (method, prefix, source) => {
    const router = createServer(source);
    const go = (request, response, done) => {
        if (request.url) {
            request.url = request.url.substring(prefix.length);
        }
        router(request, response, done);
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.prefixMatch(prefix)],
        go
    };
};
exports.routing = routing;
const concludeJson = (request, response, status, info) => {
    doResponse(request, response, status, 'application/json', JSON.stringify(info));
};
const json = (method, prefix, data) => {
    const go = (request, response /* , done */) => {
        concludeJson(request, response, 200, data);
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.prefixMatch(prefix)],
        go
    };
};
exports.json = json;
const asyncJs = (method, url, fn) => {
    const go = (request, response /* , done */) => {
        fn((data) => {
            doResponse(request, response, 200, 'application/javascript', data);
        });
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.urlMatch(url)],
        go
    };
};
exports.asyncJs = asyncJs;
const effect = (method, prefix, action) => {
    const go = (request, response /* , done */) => {
        let body = '';
        request.on('data', (data) => {
            body += data;
        });
        request.on('end', () => {
            const parsed = JSON.parse(body);
            action(parsed).then(() => {
                concludeJson(request, response, 200, {});
            }).catch((err) => {
                console.error('Executing effect failed: \n** ' + body);
                console.error('Error: ', err, '\n');
                concludeJson(request, response, 500, {});
            });
        });
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.prefixMatch(prefix)],
        go
    };
};
exports.effect = effect;
const rewrite = (method, root, input, output) => {
    const base = createServer(root);
    const go = (request, response, done) => {
        request.url = output;
        base(request, response, done);
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.prefixMatch(input)],
        go
    };
};
exports.rewrite = rewrite;
const constant = (method, root, url) => {
    const base = createServer(root);
    const go = (request, response, done) => {
        request.url = url;
        base(request, response, done);
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.prefixMatch(root)],
        go
    };
};
exports.constant = constant;
const host = (method, root) => {
    const base = createServer(root);
    const go = (request, response, done) => {
        base(request, response, done);
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.prefixMatch(root)],
        go
    };
};
exports.host = host;
const hostOn = (method, prefix, root) => {
    const base = createServer(root);
    const go = (request, response, done) => {
        if (request.url) {
            request.url = request.url.substring((prefix + '/').length);
        }
        base(request, response, done);
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.prefixMatch(prefix)],
        go
    };
};
exports.hostOn = hostOn;
const unsupported = (method, root, label) => {
    const go = (request, response /* , done */) => {
        concludeJson(request, response, 404, { error: label });
    };
    return {
        matches: [Matchers.methodMatch(method), Matchers.prefixMatch(root)],
        go
    };
};
exports.unsupported = unsupported;
const route = (routes, fallback, request, response, done) => {
    request.originalUrl = request.url;
    const match = routes.find((candidate) => {
        return candidate.matches.every((match) => {
            return match(request);
        });
    });
    const matching = match === undefined ? fallback : match;
    matching.go(request, response, done);
};
exports.route = route;
//# sourceMappingURL=Routes.js.map