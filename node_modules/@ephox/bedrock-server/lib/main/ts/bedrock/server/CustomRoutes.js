"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = void 0;
const fs = require("fs");
const mime = require("mime-types");
const path = require("path");
const Matchers = require("./Matchers");
const Obj = require("../util/Obj");
const Type = require("../util/Type");
const Routes = require("./Routes");
const FileUtils = require("../util/FileUtils");
const readRequestBody = (request, done) => {
    let body = '';
    request.on('data', (data) => {
        body += data;
    });
    request.on('end', () => {
        done(body);
    });
};
const serializeJson = (json) => {
    return JSON.stringify(json, null, 2);
};
const matchesFromRequest = (matchRequest) => {
    const matches = [];
    if (Type.isString(matchRequest.method)) {
        matches.push(Matchers.methodMatch(matchRequest.method));
    }
    if (Type.isString(matchRequest.url)) {
        matches.push(Matchers.urlMatch(matchRequest.url));
    }
    if (Type.isString(matchRequest.path)) {
        matches.push(Matchers.pathMatch(matchRequest.path));
    }
    if (Type.isObject(matchRequest.headers)) {
        matches.push(Matchers.headersMatch(matchRequest.headers));
    }
    if (Type.isObject(matchRequest.query)) {
        matches.push(Matchers.queryMatch(matchRequest.query));
    }
    if (!Type.isNull(matchRequest.json) && !Type.isUndefined(matchRequest.json)) {
        matches.push(Matchers.jsonBodyMatch(matchRequest.json));
    }
    return matches;
};
const parseJsonFromFile = (filePath, configPath) => {
    const resolvedFilePath = path.join(path.dirname(configPath), filePath);
    return FileUtils.readFileAsJson(resolvedFilePath);
};
const concludeJson = (response, status, headers, json) => {
    response.writeHead(status, { 'Content-Type': 'application/json', ...headers });
    response.end(serializeJson(json));
};
const concludeBinary = (response, status, headers, filepath) => {
    const contentType = mime.contentType(path.extname(filepath)) || 'application/octet-stream';
    const size = fs.statSync(filepath).size;
    response.writeHead(status, {
        'Content-Type': contentType,
        'Content-Length': size,
        ...headers
    });
    const stream = fs.createReadStream(filepath);
    stream.pipe(response);
};
const goFromResponse = (matchResponse, configPath) => {
    return (request, response /* , done */) => {
        const headers = matchResponse.headers ? Obj.toLowerCaseKeys(matchResponse.headers) : {};
        const status = matchResponse.status ? matchResponse.status : 200;
        if (!Type.isNull(matchResponse.json) && !Type.isUndefined(matchResponse.json)) {
            concludeJson(response, status, headers, matchResponse.json);
        }
        else if (Type.isString(matchResponse.json_file)) {
            const json = parseJsonFromFile(matchResponse.json_file, configPath);
            concludeJson(response, status, headers, json);
        }
        else if (Type.isString(matchResponse.binary_file)) {
            const resolvedFilePath = path.join(path.dirname(configPath), matchResponse.binary_file);
            concludeBinary(response, status, headers, resolvedFilePath);
        }
    };
};
const jsonToRouters = (data, configPath) => {
    return data.map((staticRouter) => {
        return {
            matches: matchesFromRequest(staticRouter.request),
            go: goFromResponse(staticRouter.response, configPath)
        };
    });
};
const fallbackGo = (filePath) => {
    return (request, response, done) => {
        response.writeHead(404, { 'content-type': 'text/plain' });
        response.end([
            'Could not find a matching custom route for: ',
            'Method: ' + request.method,
            'Url: ' + request.url,
            'Body: ' + request.body,
            'Config: ' + (filePath ? filePath : 'No config file provided')
        ].join('\n'));
        done();
    };
};
const go = (filePath) => {
    const fallback = { matches: [], go: fallbackGo(filePath) };
    return (request, response, done) => {
        const routers = filePath ? jsonToRouters(FileUtils.readFileAsJson(filePath), filePath) : [];
        readRequestBody(request, (body) => {
            request.body = body;
            Routes.route(routers, fallback, request, response, done);
        });
    };
};
const routers = (filePath) => {
    return [
        {
            matches: [Matchers.prefixMatch('/custom')],
            go: go(filePath)
        }
    ];
};
const create = (filePath) => {
    return {
        routers: routers(filePath)
    };
};
exports.create = create;
//# sourceMappingURL=CustomRoutes.js.map