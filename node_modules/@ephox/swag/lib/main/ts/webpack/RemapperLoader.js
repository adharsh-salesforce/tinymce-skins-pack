"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
exports.__esModule = true;
exports.webpackRemapperLoader = void 0;
var path = __importStar(require("path"));
var webpack_sources_1 = require("webpack-sources");
var Remapper_1 = require("../imports/Remapper");
var remapper = (0, Remapper_1.createRemapper)();
var hasInjectedCacheDropHook = false;
var deleteImports = function (remappedCode, imports) {
    [].concat(imports).reverse().forEach(function (imp) {
        remappedCode.replace(imp.start, imp.end, '');
    });
};
var remapSource = function (loaderContext, source, map) {
    var fullModulePath = path.normalize(loaderContext.resourcePath);
    var publicModulePath = path.relative(loaderContext.rootContext, fullModulePath);
    var result = (0, Remapper_1.remapImportsInSource)(remapper, source, fullModulePath);
    var inputSource = map ? new webpack_sources_1.SourceMapSource(source, publicModulePath, map) : new webpack_sources_1.OriginalSource(source, publicModulePath);
    var remappedCode = new webpack_sources_1.ReplaceSource(inputSource, publicModulePath);
    remappedCode.insert(0, result.outputImportsCode);
    deleteImports(remappedCode, result.inputImports);
    var sourceResult = remappedCode.sourceAndMap({
        // Columns in source map is rather slow to generate since we need to
        // re-generate almost every file when we remap the imports it's better to leave this option off
        columns: false
    });
    return sourceResult;
};
// Checks for `import ... from '@ephox/` or `import ... from "@ephox/` we don't need to process modules that doesn't contain these
var seemToContainEphoxImports = function (code) { return /[\'\"]@(ephox|tinymce)\//.test(code); };
// We need to generate a new remapper after a bundle is created to drop the caches it has while it's remapping
// This injects that cache drop directly into the webpack compiler the _compiler is documented as hacky but
// there doesn't seem to be a better way of doing this.
var injectCacheDropHook = function (loaderContext) {
    if (!hasInjectedCacheDropHook) {
        hasInjectedCacheDropHook = true;
        // eslint-disable-next-line no-underscore-dangle
        loaderContext._compiler.hooks.afterEmit.tap('SwagRemapper', function (_params) {
            remapper = (0, Remapper_1.createRemapper)();
        });
    }
};
var webpackRemapperLoader = function (source, map) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    var loaderContext = this;
    injectCacheDropHook(loaderContext);
    if (seemToContainEphoxImports(source)) {
        var resultMap = remapSource(loaderContext, source, map);
        loaderContext.callback(null, resultMap.source, resultMap.map);
    }
    else {
        loaderContext.callback(null, source, map);
    }
};
exports.webpackRemapperLoader = webpackRemapperLoader;
