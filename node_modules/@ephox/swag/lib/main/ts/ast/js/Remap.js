"use strict";
exports.__esModule = true;
exports.remap = void 0;
var Resolve_1 = require("../../fs/Resolve");
var Fail_1 = require("../../utils/Fail");
var Exports_1 = require("./Exports");
var Imports_1 = require("./Imports");
var MainModule_1 = require("./MainModule");
var Parser_1 = require("./Parser");
var isImport = function (node) { return node.type === 'ImportDeclaration'; };
var isWrapModuleImport = function (path) { return /^@(ephox|tinymce|tiny-premium)\/wrap\-[^\/]*/.test(path); };
var isOxideModuleImport = function (path) { return /^@(ephox|tinymce|tiny-premium)\/oxide[^\/]*/.test(path); };
var isGlobalsModuleImport = function (path) { return /^@(ephox|tinymce|tiny-premium)\/[^\-]+\-globals$/.test(path); };
var isEphoxModuleImport = function (path) { return /^@(ephox|tinymce|tiny-premium)\/[^\/]*$/.test(path); };
var isRemapTargetImport = function (path) {
    return isEphoxModuleImport(path) &&
        !isGlobalsModuleImport(path) &&
        !isWrapModuleImport(path) &&
        !isOxideModuleImport(path);
};
var findRootName = function (modulePath) {
    var parts = modulePath.split('/');
    var idx = parts.lastIndexOf('node_modules');
    return idx !== -1 ? parts.slice(0, idx).join('/') : '/';
};
var remapImport = function (fs, remapCache, id, imp, forceFlat) {
    var mainModulePath = remapCache.mainModuleResolveCache.getOrThunk(findRootName(id) + '-' + imp.modulePath, function () { return (0, Resolve_1.resolveSync)(fs, imp.modulePath, id, forceFlat); });
    var mainModule = remapCache.mainModuleCache.getOrThunk(mainModulePath, function () {
        var mainModuleProgram = (0, Parser_1.parse)(fs.readFileSync(mainModulePath).toString());
        return (0, MainModule_1.readMainModule)(mainModuleProgram);
    });
    var exportForImport = mainModule.exports.find(function (exp) { return exp.name === imp.fromName; });
    if (!exportForImport) {
        (0, Fail_1.fail)("Could not find export ".concat(imp.fromName, " in main module ").concat(mainModulePath));
    }
    // If the export is a variable declaration then we can't remap it so fail
    if (exportForImport.kind === Exports_1.ExportInfoKind.Variable) {
        (0, Fail_1.fail)([
            'Exported local variables defined as `export const = ...` are not allowed in the main module. They cannot be remapped and will greatly impede ' +
                'any tree-shaking opportunities. Instead, you should move them to a separate module and use the `export { ... }` syntax.',
            '  exported variable: ' + exportForImport.name,
            '  main module: ' + mainModulePath
        ].join('\n'));
    }
    var mainImportFromExport = mainModule.imports.find(function (mi) { return mi.name === exportForImport.fromName; });
    if (!mainImportFromExport) {
        (0, Fail_1.fail)("Could not find import ".concat(exportForImport.fromName, " in main module ").concat(mainModulePath));
    }
    var resolvedModulePath = remapCache.moduleResolveCache.getOrThunk(mainImportFromExport.modulePath + '-' + mainModulePath, function () { return (0, Resolve_1.resolveSync)(fs, mainImportFromExport.modulePath, mainModulePath, forceFlat); });
    return (0, Imports_1.createImport)(mainImportFromExport.kind, imp.name, mainImportFromExport.fromName, resolvedModulePath);
};
var remapImports = function (fs, remapCache, id, imports, forceFlat) {
    return imports.map(function (imp) {
        return isRemapTargetImport(imp.modulePath) && imp.kind !== Imports_1.ImportInfoKind.SideEffect ? remapImport(fs, remapCache, id, imp, forceFlat) : imp;
    });
};
var remap = function (fs, remapCache, id, node, forceFlat) {
    var imports = (0, Imports_1.readImports)(node);
    var body = node.body.filter(function (n) { return !isImport(n); });
    var remappedImports = remapImports(fs, remapCache, id, imports, forceFlat);
    node.body = [].concat((0, Imports_1.toAst)(remappedImports)).concat(body);
};
exports.remap = remap;
