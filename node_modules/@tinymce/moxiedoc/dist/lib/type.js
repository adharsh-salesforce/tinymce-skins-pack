"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = void 0;
const Reporter = require("./reporter");
const target_1 = require("./target");
const sortMembersByName = (members) => {
    return members.sort((a, b) => {
        if (a.name < b.name) {
            return -1;
        }
        else if (a.name > b.name) {
            return 1;
        }
        else {
            return 0;
        }
    });
};
/**
 * Type class contains details about classes, enums, structs etc.
 *
 * @class moxiedoc.Type
 */
class Type extends target_1.Target {
    /**
     * Constructs a new Type instance.
     *
     * @constructor
     * @param {Object} data Json structure with type data.
     */
    constructor(data) {
        super();
        this._members = [];
        this._mixes = [];
        for (const name in data) {
            if (data.hasOwnProperty(name)) {
                this[name] = data[name];
            }
        }
        this.name = data.name = data.name || data.fullName.split('.').pop();
    }
    /**
     * Adds a new member to the type.
     *
     * @method addMember
     * @param {Member} member Member instance to add to type.
     * @return {Member} Member info instance that was passed in.
     */
    addMember(member) {
        member._parentType = this;
        this._members.push(member);
        if (this.static) {
            member.static = true;
        }
        return member;
    }
    getMembers(includeInherited = false) {
        const self = this;
        if (this.borrows) {
            this.borrows.forEach((typeFullName) => {
                const type = self._api.getTypeByFullName(typeFullName);
                if (type) {
                    type.getMembers(true).forEach((member) => {
                        self.addMember(member.clone());
                    });
                }
                else {
                    Reporter.warn('Could not borrow members from non existing type:', typeFullName);
                }
            });
            this.borrows = null;
        }
        if (includeInherited) {
            if (this._allMembers) {
                return this._allMembers;
            }
            const members = {};
            const output = [];
            const types = this.getSuperTypes().reverse();
            types.push(this);
            types.forEach((type) => {
                type.getMixes().forEach((mixType) => {
                    mixType.getMembers().forEach((member) => {
                        member = member.clone();
                        if (type.static) {
                            member.staticLink = member.static;
                            member.static = true;
                        }
                        members[member.mixType + '.' + member.name + (member.static ? '.static' : '')] = member;
                    });
                });
                type.getMembers().forEach((member) => {
                    member.staticLink = member.static;
                    members[member.type + '.' + member.name + (member.static ? '.static' : '')] = member;
                });
            });
            for (const name in members) {
                if (members.hasOwnProperty(name)) {
                    output.push(members[name]);
                }
            }
            this._allMembers = sortMembersByName(output);
            return output;
        }
        return this._members;
    }
    getMixes() {
        const self = this;
        const api = this._api;
        const output = [];
        if (this._mixesTypes) {
            return this._mixesTypes;
        }
        this._mixes.forEach((typeFullName) => {
            const type = api.getTypeByFullName(typeFullName);
            if (type) {
                output.push(type);
            }
            else {
                Reporter.warn('Could not mixin members into: ' + self.fullName + ' from non existing type:', typeFullName);
            }
        });
        this._mixesTypes = output;
        return output;
    }
    getMixins() {
        const fullName = this.fullName;
        const mixins = [];
        if (this._mixinsTypes) {
            return this._mixinsTypes;
        }
        if (this.type === 'mixin') {
            this._api.getTypes().forEach((type) => {
                type._mixes.forEach((typeFullName) => {
                    if (typeFullName === fullName) {
                        mixins.push(type);
                    }
                });
            });
        }
        this._mixinsTypes = mixins;
        return mixins;
    }
    addMixin(mixin) {
        this._mixes.push(mixin);
        return mixin;
    }
    getSubTypes() {
        const fullName = this.fullName;
        const subTypes = [];
        this._api.getTypes().forEach((type) => {
            if (type.extends === fullName) {
                subTypes.push(type);
            }
        });
        return subTypes;
    }
    getSuperTypes() {
        const superTypes = [];
        let type = this;
        while (type) {
            type = this._api.getTypeByFullName(type.extends);
            if (type) {
                superTypes.push(type);
            }
        }
        return superTypes;
    }
    /**
     * Returns an array of the members by the specified type.
     *
     * @method getMembersByType
     * @param {String} type Type name to get members by.
     * @return {Array} Array of members of the type Member.
     */
    getMembersByType(type, includeInherited) {
        const members = [];
        this.getMembers(includeInherited).forEach((member) => {
            if (member.type === type) {
                members.push(member);
            }
        });
        return members;
    }
    /**
     * Returns an array of constructors some languages might have multiple due to overloading.
     *
     * @method getConstructors
     * @return {Array} Array of constructors of the type Member.
     */
    getConstructors(includeInherited) {
        return this.getMembersByType('constructor', includeInherited);
    }
    /**
     * Returns an array of methods.
     *
     * @method getMethods
     * @return {Array} Array of methods of the type Member.
     */
    getMethods(includeInherited) {
        return this.getMembersByType('method', includeInherited);
    }
    /**
     * Returns an array of properties.
     *
     * @method getProperties
     * @return {Array} Array of properties of the type Member.
     */
    getProperties(includeInherited) {
        return this.getMembersByType('property', includeInherited);
    }
    /**
     * Returns an array of events.
     *
     * @method getProperties
     * @return {Array} Array of events of the type Member.
     */
    getEvents(includeInherited) {
        return this.getMembersByType('event', includeInherited);
    }
    /**
     * Returns an array of fields.
     *
     * @method getFields
     * @return {Array} Array of fields of the type Member.
     */
    getFields(includeInherited) {
        return this.getMembersByType('field', includeInherited);
    }
    /**
     * Returns an array of settings.
     *
     * @method getSettings
     * @return {Array} Array of settings of the type Member.
     */
    getSettings(includeInherited) {
        return this.getMembersByType('setting', includeInherited);
    }
    /**
     * Returns an array of callbacks.
     *
     * @method getCallbacks
     * @return {Array} Array of callbacks of the type Member.
     */
    getCallbacks(includeInherited) {
        return this.getMembersByType('callback', includeInherited);
    }
    /**
     * Returns a member by name.
     *
     * @method getMemberByName
     * @param {String} name Name of the member to retrive.
     * @param {Boolean} [includeInherited] Include inherited members.
     * @return {moxiedoc.Member} Member instance or null.
     */
    getMemberByName(name, includeInherited) {
        const members = this.getMembers(includeInherited);
        for (const item of members) {
            if (item.name === name) {
                return item;
            }
        }
        return null;
    }
    /**
     * Removes all private members from the type.
     *
     * @method removePrivates
     */
    removePrivates() {
        this._members = this._members.filter((member) => member.access !== 'private');
    }
    /**
     * Serializes the Type as JSON.
     *
     * @method toJSON
     * @return {Object} JSON object.
     */
    toJSON() {
        const json = {};
        for (const name in this) {
            if (typeof (this[name]) !== 'function' && name.indexOf('_') !== 0) {
                json[name] = this[name];
            }
        }
        json.members = [];
        this._members.forEach((member) => {
            json.members.push(member.toJSON());
        });
        return json;
    }
}
exports.Type = Type;
//# sourceMappingURL=type.js.map