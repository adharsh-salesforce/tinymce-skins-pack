"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Api = void 0;
const namespace_1 = require("./namespace");
class Api {
    constructor() {
        this._namespaces = [];
        this._types = [];
        this._rootTypes = [];
        this._rootNamespaces = [];
    }
    static getNamespaceFromFullName(fullName) {
        const chunks = fullName.split('.');
        chunks.pop();
        return chunks.join('.');
    }
    getRootTypes() {
        return this._rootTypes;
    }
    addNamespace(namespace) {
        this._namespaces.push(namespace);
        return namespace;
    }
    getNamespace(fullName) {
        for (const namespace of this._namespaces) {
            if (namespace.fullName === fullName) {
                return namespace;
            }
        }
        return null;
    }
    getTypeByFullName(fullName) {
        for (const item of this._types) {
            if (item.fullName === fullName) {
                return item;
            }
        }
        return null;
    }
    createNamespace(fullName, isClass = false) {
        const self = this;
        let namespaceFullName;
        namespaceFullName = isClass ? Api.getNamespaceFromFullName(fullName) : fullName;
        // Get or create namespace for type
        let namespace = self.getNamespace(namespaceFullName);
        if (!namespace && namespaceFullName) {
            const fullNameChunks = namespaceFullName.split('.');
            namespaceFullName = '';
            fullNameChunks.forEach((chunk) => {
                if (namespaceFullName) {
                    namespaceFullName += '.';
                }
                namespaceFullName += chunk;
                const targetNamespace = self.getNamespace(namespaceFullName);
                if (!targetNamespace) {
                    const newNameSpace = new namespace_1.Namespace({ fullName: namespaceFullName });
                    if (namespace) {
                        namespace.addChildNamespace(newNameSpace);
                    }
                    else {
                        self._rootNamespaces.push(newNameSpace);
                    }
                    self._namespaces.push(newNameSpace);
                    namespace = newNameSpace;
                }
                else {
                    namespace = targetNamespace;
                }
            });
        }
        return namespace;
    }
    addType(type) {
        if (typeof type === 'string') {
            const existingType = this.getTypeByFullName(type);
            if (existingType) {
                return existingType;
            }
        }
        else {
            const namespace = this.createNamespace(type.fullName, true);
            if (namespace) {
                namespace.addType(type);
            }
            else {
                this._rootTypes.push(type);
            }
            this._types.push(type);
            type._api = this;
            return type;
        }
    }
    getTypes() {
        return this._types;
    }
    getNamespaces() {
        return this._namespaces;
    }
    getRootNamespaces() {
        return this._rootNamespaces;
    }
    removePrivates() {
        this._types = this._types.filter((type) => {
            type.removePrivates();
            return type.access !== 'private';
        });
        this._namespaces = this._namespaces.filter((namespace) => {
            namespace.removePrivates();
            if (namespace.getTypes().length + namespace.getNamespaces().length === 0) {
                return false;
            }
            return namespace.access !== 'private';
        });
        this._rootNamespaces = this._namespaces.filter((namespace) => {
            namespace.removePrivates();
            if (namespace.getTypes().length + namespace.getNamespaces().length === 0) {
                return false;
            }
            return namespace.access !== 'private';
        });
    }
    /**
     * Serializes the Type as JSON.
     *
     * @method toJSON
     * @return {Object} JSON object.
     */
    toJSON() {
        const json = {};
        for (const name in this) {
            if (typeof (this[name]) !== 'function' && name.indexOf('_') !== 0) {
                json[name] = this[name];
            }
        }
        json.types = [];
        this._types.forEach((type) => {
            json.types.push(type.toJSON());
        });
        return json;
    }
}
exports.Api = Api;
//# sourceMappingURL=api.js.map