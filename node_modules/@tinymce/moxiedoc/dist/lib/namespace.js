"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Namespace = void 0;
const target_1 = require("./target");
/**
 * Namespace class.
 *
 * @class moxiedoc.Namespace
 */
class Namespace extends target_1.Target {
    /**
     * Constructs a new Namespace instance.
     *
     * @constructor
     * @param {Object} data Json structure with member data.
     */
    constructor(data) {
        super();
        this._types = [];
        this._namespaces = [];
        for (const name in data) {
            if (data.hasOwnProperty(name)) {
                this[name] = data[name];
            }
        }
    }
    addChildNamespace(namespace) {
        this._namespaces.push(namespace);
        namespace._parent = this;
        return namespace;
    }
    getParent() {
        return this._parent;
    }
    getNamespaces() {
        return this._namespaces;
    }
    addType(type) {
        this._types.push(type);
        return type;
    }
    getTypes() {
        return this._types;
    }
    /**
     * Returns an array of the types by the specified type.
     *
     * @method getMembersByType
     * @param {String} typeName Type name to get members by.
     * @return {Array} Array of members of the type MemberInfo.
     */
    getTypesByType(typeName) {
        const types = [];
        this._types.forEach((type) => {
            if (type.type === typeName) {
                types.push(type);
            }
        });
        return types;
    }
    /**
     * Returns an array of classes.
     *
     * @method getClasses
     * @return {Array} Array of classes of the type Type.
     */
    getClasses() {
        return this.getTypesByType('class');
    }
    /**
     * Returns an array of mixins.
     *
     * @method getMixins
     * @return {Array} Array of mixins of the type Type.
     */
    getMixins() {
        return this.getTypesByType('mixin');
    }
    /**
     * Returns an array of structs.
     *
     * @method getStructs
     * @return {Array} Array of structs of the type Type.
     */
    getStructs() {
        return this.getTypesByType('struct');
    }
    /**
     * Removes all private types from the namespace.
     *
     * @method removePrivates
     */
    removePrivates() {
        this._types = this._types.filter((type) => type.access !== 'private');
        this._namespaces = this._namespaces.filter((namespace) => {
            namespace.removePrivates();
            if (namespace.getTypes().length + namespace.getNamespaces().length === 0) {
                return false;
            }
            return namespace.access !== 'private';
        });
    }
    /**
     * Serializes the Namespace as JSON.
     *
     * @method toJSON
     * @return {Object} JSON object.
     */
    toJSON() {
        const json = {
            types: [],
            namespaces: []
        };
        for (const name in this) {
            if (typeof name !== 'function' && name.indexOf('_') !== 0) {
                json[name] = this[name];
            }
        }
        this._types.forEach((type) => {
            json.types.push(type.toJSON());
        });
        this._namespaces.forEach((namespace) => {
            json.namespaces.push(namespace.toJSON());
        });
        return json;
    }
}
exports.Namespace = Namespace;
//# sourceMappingURL=namespace.js.map