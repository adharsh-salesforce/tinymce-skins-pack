"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preferMcAgarTinyDom = void 0;
const EditorUtils_1 = require("../utils/EditorUtils");
const ExtractUtils_1 = require("../utils/ExtractUtils");
const PathUtils_1 = require("../utils/PathUtils");
const createTinyDomFixer = (node, type) => (fixer) => {
    var _a;
    const editorApiCall = node.arguments[0];
    const editorVar = (_a = (0, ExtractUtils_1.extractIdentifier)(editorApiCall.callee)) === null || _a === void 0 ? void 0 : _a.name;
    return fixer.replaceText(node, `TinyDom.${type}(${editorVar})`);
};
const extractTinyDomCall = (node) => {
    const callee = node.callee;
    if (callee.type === 'MemberExpression' && node.arguments.length === 1) {
        const [object, property] = (0, ExtractUtils_1.extractMemberIdentifiers)(callee);
        if ((object === null || object === void 0 ? void 0 : object.name) === 'SugarElement' && (property === null || property === void 0 ? void 0 : property.name) === 'fromDom') {
            const firstArg = node.arguments[0];
            if (firstArg.type === 'CallExpression') {
                if ((0, EditorUtils_1.isEditorFunction)(firstArg, 'getBody')) {
                    return 'body';
                }
                else if ((0, EditorUtils_1.isEditorFunction)(firstArg, 'getDoc')) {
                    return 'document';
                }
                else if ((0, EditorUtils_1.isEditorFunction)(firstArg, 'getContainer')) {
                    return 'container';
                }
                else if ((0, EditorUtils_1.isEditorFunction)(firstArg, 'getContentAreaContainer')) {
                    return 'contentAreaContainer';
                }
                else if ((0, EditorUtils_1.isEditorFunction)(firstArg, 'getElement')) {
                    return 'targetElement';
                }
            }
        }
    }
    return null;
};
exports.preferMcAgarTinyDom = {
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Prefer using the McAgar TinyDom helper functions, instead of generic functions.'
        },
        messages: {
            preferTinyDomBody: 'Use `TinyDom.body` instead of manually converting the editor body to a Sugar element.',
            preferTinyDomDocument: 'Use `TinyDom.document` instead of manually converting the editor document to a Sugar element.',
            preferTinyDomContainer: 'Use `TinyDom.container` instead of manually converting the editor container to a Sugar element.',
            preferTinyDomContentAreaContainer: 'Use `TinyDom.contentAreaContainer` instead of manually converting the editor content area' +
                ' container to a Sugar element.',
            preferTinyDomTargetElement: 'Use `TinyDom.targetElement` instead of manually converting the editor target element to a Sugar element.',
        },
        fixable: 'code'
    },
    create: (context) => {
        const report = (func, messageId, fix) => {
            context.report({
                node: func,
                messageId,
                fix
            });
        };
        if ((0, PathUtils_1.isPathInTest)(context.getFilename())) {
            return {
                CallExpression: (node) => {
                    if (node.type === 'CallExpression') {
                        const tinyDomCall = extractTinyDomCall(node);
                        if (tinyDomCall !== null) {
                            const messageId = 'preferTinyDom' + tinyDomCall.charAt(0).toUpperCase() + tinyDomCall.slice(1);
                            report(node, messageId, createTinyDomFixer(node, tinyDomCall));
                        }
                    }
                }
            };
        }
        else {
            return {};
        }
    }
};
//# sourceMappingURL=PreferMcAgarTinyDom.js.map