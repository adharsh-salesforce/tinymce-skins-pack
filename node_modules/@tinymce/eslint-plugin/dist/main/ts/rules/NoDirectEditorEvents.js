"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noDirectEditorEvents = void 0;
const EditorUtils_1 = require("../utils/EditorUtils");
const ExtractUtils_1 = require("../utils/ExtractUtils");
const PathUtils_1 = require("../utils/PathUtils");
exports.noDirectEditorEvents = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Disallows editor events from being dispatched outside api/Events.ts.'
        },
        messages: {
            noDirectEditorEvents: 'Dispatching events is forbidden outside api/Events.ts.',
        }
    },
    create: (context) => {
        const filename = (0, PathUtils_1.normalizeFilePath)(context.getFilename());
        // Ignore in tests, demos or Events.ts
        // NOTE: To allow for some legacy setups we currently only enforce `Events.ts` instead of `api/Events.ts`
        if ((0, PathUtils_1.isPathInTest)(filename) || (0, PathUtils_1.isPathInDemo)(filename) || filename.endsWith('/Events.ts')) {
            return {};
        }
        else {
            return {
                CallExpression: (node) => {
                    var _a, _b;
                    const callee = node.callee;
                    if (callee.type === 'MemberExpression' && (0, EditorUtils_1.isEditorMemberExpression)(callee)) {
                        const identifiers = (0, ExtractUtils_1.extractMemberIdentifiers)(callee);
                        if (((_a = identifiers[1]) === null || _a === void 0 ? void 0 : _a.name) === 'dispatch' || ((_b = identifiers[1]) === null || _b === void 0 ? void 0 : _b.name) === 'fire') {
                            context.report({
                                node,
                                messageId: 'noDirectEditorEvents'
                            });
                        }
                    }
                }
            };
        }
    }
};
//# sourceMappingURL=NoDirectEditorEvents.js.map